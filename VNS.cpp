#include "Python.h"
#include <string>
#include <iostream>
#include <vector>
#include<iostream>
#include<queue>
#include<stdlib.h>
#include<ctime>
#include<cstdlib>
#include<math.h>
#include<random>
#include<unordered_map>
#include<string>
#include<cstring>
#include<fstream>
#include<algorithm>
#include<vector>
#include <windows.h>
#include<gsl/gsl_rng.h>
#include<gsl/gsl_randist.h>
#define timenum 168//总优化时段为24小时
#define day 7//7天
#define slice 1//1小时划分为1个时段
#define Msli 1
#define totalday 1000//
#define docnum 20
#define minwork 4
#define maxwork 9
#define iteras 10
#define cor1 1.0
#define cor2 240.0
#define cor3 1.0
#define K 5
#define nightlong 8//夜班长度
#define nightstart 16//将夜班结束视为一天的开始（0点），因此夜班开始为16点
#define nowtype 0//1表示看完内队列病人再离开
#define maxnight 2//单个医生最多值夜班数
#define resthour 8//休息班次固定在每天的什么时候
#define shakeadd 10//shake调整班次数目增加数
#define maxcheck 2
#define ifM 0

#define defaultM 8
#define feature 3
#define decodetype 4
#define offset 0
#define numcase 6
#define maxM 10
#define minM 3
using namespace std;

int Schedule[slice * timenum] = { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 };
unordered_map<string, double> Hashmap0;
unordered_map<string, double> Hashmap1;
unordered_map<string, double> Hashmap2;
//const double Arrive_rate[timenum] = { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 };
//double Arrive_rate[timenum] = { 4,3,3,2,2,1,1,2,2,3,6,8,8,7,5,6,7,7,6,6,5,7,6,5 };  //test
double Arrive_rate[timenum] = { 29,14,20,15,11,14,9,11,17,14,11,15,24,29,14,9,2,3,5,4,1,3,20,25 };

double Arrive_exp[day][timenum / day] = {
	{14.33333333,19.44444444,21.55555556,22.11111111,17.11111111,13.88888889,19,21.11111111,18.22222222,13.22222222,12.66666667,13.22222222,16.88888889,13,12.33333333,10.55555556,7,5.29390681,3.103942652,3.91218638,3.327956989,3.611111111,10.98387097,15.43548387},
	{ 17.24193548,20.91218638,25.29390681,23.67741935,24.04659498,17.81362007,20.84587814,23.94623656,19.81362007,16.15770609,11.80286738,14.41935484,13.8655914,14.51612903,12.63082437,10.01971326,7.534050179,5.5,3.5,2.5,2.375,4.25,4.875,20.875 } ,
	{18.25,23.125,26.625,27.125,19.625,20.625,22.5,24,19.5,17,15.25,13.875,17.875,15,11.625,6.875,5.875,4.444444444,3.111111111,3.666666667,3,4.111111111,5.888888889,17.22222222},
	{16.55555556,22.33333333,25.11111111,22.88888889,20.11111111,15.88888889,21.55555556,19.66666667,16.44444444,14.88888889,13.11111111,12.33333333,15.44444444,14.66666667,12.66666667,7,6.111111111,4.333333333,3.111111111,3.444444444,3,3.777777778,7,18.55555556},
	{16,21.77777778,24.44444444,24.44444444,19.11111111,14.66666667,20.22222222,20.44444444,17,14,11.55555556,12.22222222,11.88888889,11.11111111,7.888888889,7.111111111,5.555555556,4.444444444,2.777777778,2.444444444,3.555555556,2.222222222,5.111111111,21.22222222},
	{14.55555556,25.22222222,26.88888889,24.44444444,18,16,21.77777778,20.88888889,15.88888889,12.33333333,10.77777778,10.77777778,14.88888889,11.11111111,8.111111111,7.666666667,4.555555556,4.777777778,1.555555556,3.333333333,3.777777778,3.555555556,8.555555556,21.11111111},
	{17.88888889,23.11111111,24.44444444,24.66666667,19,16.33333333,20.11111111,22,15.33333333,14.88888889,11.55555556,12.88888889,13.55555556,16.77777778,10.22222222,8.333333333,4.333333333,4.333333333,3.666666667,3.444444444,1.888888889,3.222222222,6.111111111,19.33333333 }
};
double Arrive_exp2[day][timenum / day] = {
	{13.26,17.34,19.38,14.28,9.18,19.38,15.3,15.3,27.54,12.24,16.32,25.5,25.5,22.44,8.16,10.2,3.96039604,3.96039604,4.95049505,2.475247525,3.465346535,6.930693069,17.82178218,28.71287129},
	{29.20792079,31.18811881,29.7029703,31.18811881,17.32673267,19.30693069,21.28712871,18.81188119,20.79207921,9.900990099,11.88118812,14.85148515,16.83168317,9.405940594,9.405940594,7.920792079,2.215880412,2.408224016,3.360420076,2.613916854,3.566112914,5.731665604,11.53728818,17.34291076},
	{18.0524355,19.48997421,19.22881364,20.42368102,14.0957373,15.53327602,16.97081473,16.22431151,17.66185022,12.78993446,14.22747317,16.15035453,17.58789324,14.41467676,14.88153017,14.6203696,6.12,6.12,4.59,15.3,7.65,8.02,9.66,10.71},
	{18.36, 30.6, 29.07, 21.42, 30.6, 39.78, 16.83, 7.65, 6.12, 10.71, 15.3, 16.83, 1.53, 16.83, 13.77, 15.3, 7.619047619, 3.80952381, 5.714285714, 5.714285714, 3.80952381, 10, 12.85714286, 10},
	{13.80952381, 21.42857143, 22.85714286, 25.23809524, 23.33333333, 24.28571429, 20, 21.9047619, 14.76190476, 16.19047619, 15.23809524, 12.85714286, 9.523809524, 18.0952381, 13.33333333, 10.95238095, 4.761904762, 6.19047619, 4.285714286, 4.285714286, 4.761904762, 7.142857143, 16.19047619, 26.19047619},
	{29.52380952,27.61904762,23.80952381,30.47619048,20,19.52380952,20.95238095,18.57142857,20,10.95238095,10,15.23809524,13.33333333,10.95238095,10.95238095,7.142857143,6.956521739,0.869565217,3.47826087,2.608695652,7.826086957,11.04347826,15.13043478,20},
	{20.86956522,31.30434783,25.2173913,29.56521739,13.04347826,13.04347826,27.6,23.47826087,19.13043478,11.30434783,18.26086957,17.39130435,28.69565217,16.52173913,8.695652174,8.695652174,6.12,6.12,7.14,4.08,4.08,7.54,12.03,22.44}
};
double Arrive_exp3[day][timenum / day] = {
	{15.81,20.4,24.99,18.87,13.77,21.42,15.81,22.95,16.83,12.24,11.73,16.32,16.32,10.71,4.59,5.61,7.21,4.12,1.03,3.09,4.12,3.09,15.45,13.39},
	{22.66,27.81,19.57,16.48,15.45,27.81,26.78,23.69,11.33,11.33,7.21,22.66,18.54,12.36,8.24,4.12,6.18,2.06,5.15,1.03,5.15,9.27,23.3,20.6},
	{22.66,41.2,30.9,18.54,16.48,25.75,25.75,14.42,14.42,5.15,13.39,10.3,14.42,8.24,6.18,4.12,4.4,3.3,3.85,3.3,1.65,4.95,18.15,18.15},
	{24.75,23.1,28.05,20.9,18.15,20.35,17.05,16.5,18.7,16.5,11,14.3,11.55,10.45,8.25,6.05,4.4,1.65,2.75,3.3,2.75,6.05,20.35,12.65},
	{21.45,30.25,20.35,15.95,16.5,22.55,18.7,22,19.8,15.4,12.1,12.1,9.9,9.9,7.15,5.5,4.4,3.3,3.85,3.3,1.65,4.95,18.15,18.15},
	{24.75,23.1,28.05,20.9,18.15,20.35,17.05,16.5,18.7,16.5,11,14.3,11.55,10.45,8.25,6.05,4.12,4.12,5.15,5.15,2.06,7.21,22.66,23.69},
	{35.02,24.72,37.08,29.87,23.69,23.69,23.69,19.57,17.51,14.42,15.45,15.45,9.27,10.3,14.42,5.15,4.59,3.57,2.04,3.06,3.57,6.12,24.48,15.3}
};
double Arrive_exp4[day][timenum / day] = {
	{23.688,28.1295,24.675,24.675,25.1685,18.2595,20.2335,19.2465,18.753,20.2335,13.3245,19.2465,16.2855,14.3115,7.4025,6.909,2.777777778,6.25,5.555555556,3.472222222,3.472222222,13.19444444,28.47222222,29.86111111},
	{21.52777778,22.22222222,20.13888889,20.83333333,12.5,21.52777778,18.75,11.80555556,16.66666667,17.36111111,17.36111111,18.05555556,20.83333333,15.97222222,8.333333333,6.25,7.4025,1.4805,2.961,2.961,6.4155,4.935,13.3245,20.2335},
	{19.2465,26.649,28.623,24.675,22.2075,16.779,17.2725,21.714,15.2985,18.2595,11.844,17.766,13.3245,12.831,7.896,4.935,3.666666667,2,2.666666667,2.666666667,2,4.666666667,10.33333333,12.33333333},
	{17.33333333,17.66666667,13,10.66666667,11.66666667,13,14.66666667,13.66666667,8,9.333333333,11.33333333,14.66666667,7,6,3,6,5.922,1.974,1.974,4.4415,6.909,5.922,15.2985,19.2465},
	{24.1815,26.649,29.1165,24.675,22.2075,19.2465,18.2595,20.727,16.2855,22.701,15.792,18.2595,12.3375,11.844,7.896,5.4285,1.833333333,2.2,2.2,1.833333333,1.1,2.2,9.9,10.26666667},
	{15.76666667,20.9,13.93333333,13.2,12.46666667,15.76666667,12.1,11.36666667,9.9,7.7,11.36666667,15.76666667,13.93333333,8.066666667,4.766666667,4.033333333,5.4285,1.974,1.974,2.961,6.909,4.4415,15.792,17.766},
	{27.636,24.675,32.571,24.675,24.675,15.792,19.2465,21.714,14.805,18.753,15.792,18.753,14.3115,12.831,7.4025,5.4285,5.922,2.4675,1.974,3.4545,8.3895,4.4415,13.818,19.74}
};
double Arrive_exp5[day][timenum / day] = {
	{20.8,20.28,17.68,14.04,15.08,13,17.16,16.64,12.48,10.92,8.84,13,9.88,6.76,6.24,5.2,4.68,5.2,2.6,1.04,3.64,8.32,17.16,21.32},
	{20.8,26,21.84,15.6,15.6,15.6,18.2,16.64,17.68,10.92,7.28,13.52,7.8,11.44,7.28,5.72,6.24,3.64,2.6,3.12,3.12,4.16,11.44,17.16},
{27.56,29.12,27.56,13,17.16,23.92,22.88,17.16,16.64,11.44,5.2,15.08,9.88,15.6,10.4,7.28,5.2,3.64,4.16,3.12,2.6,4.68,19.76,16.12},
{34.84,34.32,23.4,15.08,15.08,19.76,19.76,20.28,19.76,18.2,10.4,13.52,15.6,8.84,5.72,8.32,3.64,4.16,3.64,2.08,3.64,7.28,16.64,19.24},
{18.72,31.2,18.2,22.88,18.72,21.84,24.44,16.64,15.08,16.12,14.04,12.48,16.64,12.48,10.92,8.84,5.72,6.24,4.16,2.08,1.04,1.56,13,16.12},
{20.28,29.64,27.56,17.16,14.56,20.28,23.4,12.48,14.04,14.04,14.56,11.44,16.12,8.84,3.12,5.2,6.24,5.72,2.6,2.08,1.56,7.28,20.28,17.68},
{21.32,27.56,22.36,21.84,16.64,17.68,24.44,21.32,18.2,13.52,14.56,14.56,13,13,6.24,6.76,4.16,2.6,3.12,1.56,1.04,7.8,20.8,11.96}
};
double Arrive_exp6[day][timenum / day] = {
	{30.597,30.1035,28.623,24.1815,21.2205,24.675,24.1815,23.688,17.766,12.831,15.792,12.831,7.4025,9.3765,12.831,4.4415,5.4285,3.948,2.961,3.948,2.961,4.935,18.2595,17.766},
{27.636,25.1685,27.1425,22.2075,18.753,23.1,22.2,20.727,13.818,12.3375,10.857,18.2595,13.3245,10.857,10.857,4.2,4.488888889,3.142222222,3.703333333,3.03,4.152222222,5.947777778,17.39444444,16.72111111},
{22.55666667,25.36222222,23.11777778,20.31222222,16.04777778,21.77111111,19.86333333,16.60888889,15.03777778,13.24222222,12.45666667,15.59888889,14.81333333,12.79333333,7.07,6.172222222,3.4545,4.4415,5.922,4.4415,1.974,6.909,16.2855,21.2205},
{28.623,22.701,29.1165,21.714,18.753,19.74,16.779,17.2725,16.779,10.857,13.3245,15.792,13.3245,8.3895,12.831,6.4155,4.488888889,2.805555556,2.468888889,3.591111111,2.244444444,5.162222222,21.43444444,14.70111111},
{25.47444444,27.15777778,24.68888889,18.18,16.16,21.99555556,21.09777778,16.04777778,12.45666667,10.88555556,10.88555556,15.03777778,11.22222222,8.192222222,7.743333333,4.601111111,4.376666667,3.142222222,3.478888889,3.03,3.815555556,7.07,18.74111111,16.16},
{21.99555556,24.68888889,24.68888889,19.30222222,14.81333333,20.42444444,20.64888889,17.17,14.14,11.67111111,12.34444444,12.00777778,11.22222222,7.967777778,7.182222222,5.611111111,4.825555556,1.571111111,3.366666667,3.815555556,3.591111111,8.641111111,21.32222222,18.06777778},
{23.34222222,24.68888889,24.91333333,19.19,16.49666667,20.31222222,22.22,15.48666667,15.03777778,11.67111111,13.01777778,13.69111111,16.94555556,10.32444444,8.416666667,4.376666667,3.948,2.4675,3.948,4.935,2.961,7.896,12.34,17.766}
};
double Arrive_expp[numcase][day][timenum / day] = {
	{
	{14.33333333,19.44444444,21.55555556,22.11111111,17.11111111,13.88888889,19,21.11111111,18.22222222,13.22222222,12.66666667,13.22222222,16.88888889,13,12.33333333,10.55555556,7,5.29390681,3.103942652,3.91218638,3.327956989,3.611111111,10.98387097,15.43548387},
	{ 17.24193548,20.91218638,25.29390681,23.67741935,24.04659498,17.81362007,20.84587814,23.94623656,19.81362007,16.15770609,11.80286738,14.41935484,13.8655914,14.51612903,12.63082437,10.01971326,7.534050179,5.5,3.5,2.5,2.375,4.25,4.875,20.875 } ,
	{18.25,23.125,26.625,27.125,19.625,20.625,22.5,24,19.5,17,15.25,13.875,17.875,15,11.625,6.875,5.875,4.444444444,3.111111111,3.666666667,3,4.111111111,5.888888889,17.22222222},
	{16.55555556,22.33333333,25.11111111,22.88888889,20.11111111,15.88888889,21.55555556,19.66666667,16.44444444,14.88888889,13.11111111,12.33333333,15.44444444,14.66666667,12.66666667,7,6.111111111,4.333333333,3.111111111,3.444444444,3,3.777777778,7,18.55555556},
	{16,21.77777778,24.44444444,24.44444444,19.11111111,14.66666667,20.22222222,20.44444444,17,14,11.55555556,12.22222222,11.88888889,11.11111111,7.888888889,7.111111111,5.555555556,4.444444444,2.777777778,2.444444444,3.555555556,2.222222222,5.111111111,21.22222222},
	{14.55555556,25.22222222,26.88888889,24.44444444,18,16,21.77777778,20.88888889,15.88888889,12.33333333,10.77777778,10.77777778,14.88888889,11.11111111,8.111111111,7.666666667,4.555555556,4.777777778,1.555555556,3.333333333,3.777777778,3.555555556,8.555555556,21.11111111},
	{17.88888889,23.11111111,24.44444444,24.66666667,19,16.33333333,20.11111111,22,15.33333333,14.88888889,11.55555556,12.88888889,13.55555556,16.77777778,10.22222222,8.333333333,4.333333333,4.333333333,3.666666667,3.444444444,1.888888889,3.222222222,6.111111111,19.33333333 }
},
{
	{13.26,17.34,19.38,14.28,9.18,19.38,15.3,15.3,27.54,12.24,16.32,25.5,25.5,22.44,8.16,10.2,3.96039604,3.96039604,4.95049505,2.475247525,3.465346535,6.930693069,17.82178218,28.71287129},
	{29.20792079,31.18811881,29.7029703,31.18811881,17.32673267,19.30693069,21.28712871,18.81188119,20.79207921,9.900990099,11.88118812,14.85148515,16.83168317,9.405940594,9.405940594,7.920792079,2.215880412,2.408224016,3.360420076,2.613916854,3.566112914,5.731665604,11.53728818,17.34291076},
	{18.0524355,19.48997421,19.22881364,20.42368102,14.0957373,15.53327602,16.97081473,16.22431151,17.66185022,12.78993446,14.22747317,16.15035453,17.58789324,14.41467676,14.88153017,14.6203696,6.12,6.12,4.59,15.3,7.65,8.02,9.66,10.71},
	{18.36, 30.6, 29.07, 21.42, 30.6, 39.78, 16.83, 7.65, 6.12, 10.71, 15.3, 16.83, 1.53, 16.83, 13.77, 15.3, 7.619047619, 3.80952381, 5.714285714, 5.714285714, 3.80952381, 10, 12.85714286, 10},
	{13.80952381, 21.42857143, 22.85714286, 25.23809524, 23.33333333, 24.28571429, 20, 21.9047619, 14.76190476, 16.19047619, 15.23809524, 12.85714286, 9.523809524, 18.0952381, 13.33333333, 10.95238095, 4.761904762, 6.19047619, 4.285714286, 4.285714286, 4.761904762, 7.142857143, 16.19047619, 26.19047619},
	{29.52380952,27.61904762,23.80952381,30.47619048,20,19.52380952,20.95238095,18.57142857,20,10.95238095,10,15.23809524,13.33333333,10.95238095,10.95238095,7.142857143,6.956521739,0.869565217,3.47826087,2.608695652,7.826086957,11.04347826,15.13043478,20},
	{20.86956522,31.30434783,25.2173913,29.56521739,13.04347826,13.04347826,27.6,23.47826087,19.13043478,11.30434783,18.26086957,17.39130435,28.69565217,16.52173913,8.695652174,8.695652174,6.12,6.12,7.14,4.08,4.08,7.54,12.03,22.44}
},
{
	{15.81,20.4,24.99,18.87,13.77,21.42,15.81,22.95,16.83,12.24,11.73,16.32,16.32,10.71,4.59,5.61,7.21,4.12,1.03,3.09,4.12,3.09,15.45,13.39},
	{22.66,27.81,19.57,16.48,15.45,27.81,26.78,23.69,11.33,11.33,7.21,22.66,18.54,12.36,8.24,4.12,6.18,2.06,5.15,1.03,5.15,9.27,23.3,20.6},
	{22.66,41.2,30.9,18.54,16.48,25.75,25.75,14.42,14.42,5.15,13.39,10.3,14.42,8.24,6.18,4.12,4.4,3.3,3.85,3.3,1.65,4.95,18.15,18.15},
	{24.75,23.1,28.05,20.9,18.15,20.35,17.05,16.5,18.7,16.5,11,14.3,11.55,10.45,8.25,6.05,4.4,1.65,2.75,3.3,2.75,6.05,20.35,12.65},
	{21.45,30.25,20.35,15.95,16.5,22.55,18.7,22,19.8,15.4,12.1,12.1,9.9,9.9,7.15,5.5,4.4,3.3,3.85,3.3,1.65,4.95,18.15,18.15},
	{24.75,23.1,28.05,20.9,18.15,20.35,17.05,16.5,18.7,16.5,11,14.3,11.55,10.45,8.25,6.05,4.12,4.12,5.15,5.15,2.06,7.21,22.66,23.69},
	{35.02,24.72,37.08,29.87,23.69,23.69,23.69,19.57,17.51,14.42,15.45,15.45,9.27,10.3,14.42,5.15,4.59,3.57,2.04,3.06,3.57,6.12,24.48,15.3}
},
 {
	{23.688,28.1295,24.675,24.675,25.1685,18.2595,20.2335,19.2465,18.753,20.2335,13.3245,19.2465,16.2855,14.3115,7.4025,6.909,2.777777778,6.25,5.555555556,3.472222222,3.472222222,13.19444444,28.47222222,29.86111111},
	{21.52777778,22.22222222,20.13888889,20.83333333,12.5,21.52777778,18.75,11.80555556,16.66666667,17.36111111,17.36111111,18.05555556,20.83333333,15.97222222,8.333333333,6.25,7.4025,1.4805,2.961,2.961,6.4155,4.935,13.3245,20.2335},
	{19.2465,26.649,28.623,24.675,22.2075,16.779,17.2725,21.714,15.2985,18.2595,11.844,17.766,13.3245,12.831,7.896,4.935,3.666666667,2,2.666666667,2.666666667,2,4.666666667,10.33333333,12.33333333},
	{17.33333333,17.66666667,13,10.66666667,11.66666667,13,14.66666667,13.66666667,8,9.333333333,11.33333333,14.66666667,7,6,3,6,5.922,1.974,1.974,4.4415,6.909,5.922,15.2985,19.2465},
	{24.1815,26.649,29.1165,24.675,22.2075,19.2465,18.2595,20.727,16.2855,22.701,15.792,18.2595,12.3375,11.844,7.896,5.4285,1.833333333,2.2,2.2,1.833333333,1.1,2.2,9.9,10.26666667},
	{15.76666667,20.9,13.93333333,13.2,12.46666667,15.76666667,12.1,11.36666667,9.9,7.7,11.36666667,15.76666667,13.93333333,8.066666667,4.766666667,4.033333333,5.4285,1.974,1.974,2.961,6.909,4.4415,15.792,17.766},
	{27.636,24.675,32.571,24.675,24.675,15.792,19.2465,21.714,14.805,18.753,15.792,18.753,14.3115,12.831,7.4025,5.4285,5.922,2.4675,1.974,3.4545,8.3895,4.4415,13.818,19.74}
},
{
	{20.8,20.28,17.68,14.04,15.08,13,17.16,16.64,12.48,10.92,8.84,13,9.88,6.76,6.24,5.2,4.68,5.2,2.6,1.04,3.64,8.32,17.16,21.32},
	{20.8,26,21.84,15.6,15.6,15.6,18.2,16.64,17.68,10.92,7.28,13.52,7.8,11.44,7.28,5.72,6.24,3.64,2.6,3.12,3.12,4.16,11.44,17.16},
{27.56,29.12,27.56,13,17.16,23.92,22.88,17.16,16.64,11.44,5.2,15.08,9.88,15.6,10.4,7.28,5.2,3.64,4.16,3.12,2.6,4.68,19.76,16.12},
{34.84,34.32,23.4,15.08,15.08,19.76,19.76,20.28,19.76,18.2,10.4,13.52,15.6,8.84,5.72,8.32,3.64,4.16,3.64,2.08,3.64,7.28,16.64,19.24},
{18.72,31.2,18.2,22.88,18.72,21.84,24.44,16.64,15.08,16.12,14.04,12.48,16.64,12.48,10.92,8.84,5.72,6.24,4.16,2.08,1.04,1.56,13,16.12},
{20.28,29.64,27.56,17.16,14.56,20.28,23.4,12.48,14.04,14.04,14.56,11.44,16.12,8.84,3.12,5.2,6.24,5.72,2.6,2.08,1.56,7.28,20.28,17.68},
{21.32,27.56,22.36,21.84,16.64,17.68,24.44,21.32,18.2,13.52,14.56,14.56,13,13,6.24,6.76,4.16,2.6,3.12,1.56,1.04,7.8,20.8,11.96}
},
{
	{30.597,30.1035,28.623,24.1815,21.2205,24.675,24.1815,23.688,17.766,12.831,15.792,12.831,7.4025,9.3765,12.831,4.4415,5.4285,3.948,2.961,3.948,2.961,4.935,18.2595,17.766},
{27.636,25.1685,27.1425,22.2075,18.753,23.1,22.2,20.727,13.818,12.3375,10.857,18.2595,13.3245,10.857,10.857,4.2,4.488888889,3.142222222,3.703333333,3.03,4.152222222,5.947777778,17.39444444,16.72111111},
{22.55666667,25.36222222,23.11777778,20.31222222,16.04777778,21.77111111,19.86333333,16.60888889,15.03777778,13.24222222,12.45666667,15.59888889,14.81333333,12.79333333,7.07,6.172222222,3.4545,4.4415,5.922,4.4415,1.974,6.909,16.2855,21.2205},
{28.623,22.701,29.1165,21.714,18.753,19.74,16.779,17.2725,16.779,10.857,13.3245,15.792,13.3245,8.3895,12.831,6.4155,4.488888889,2.805555556,2.468888889,3.591111111,2.244444444,5.162222222,21.43444444,14.70111111},
{25.47444444,27.15777778,24.68888889,18.18,16.16,21.99555556,21.09777778,16.04777778,12.45666667,10.88555556,10.88555556,15.03777778,11.22222222,8.192222222,7.743333333,4.601111111,4.376666667,3.142222222,3.478888889,3.03,3.815555556,7.07,18.74111111,16.16},
{21.99555556,24.68888889,24.68888889,19.30222222,14.81333333,20.42444444,20.64888889,17.17,14.14,11.67111111,12.34444444,12.00777778,11.22222222,7.967777778,7.182222222,5.611111111,4.825555556,1.571111111,3.366666667,3.815555556,3.591111111,8.641111111,21.32222222,18.06777778},
{23.34222222,24.68888889,24.91333333,19.19,16.49666667,20.31222222,22.22,15.48666667,15.03777778,11.67111111,13.01777778,13.69111111,16.94555556,10.32444444,8.416666667,4.376666667,3.948,2.4675,3.948,4.935,2.961,7.896,12.34,17.766}
}
};
double Arrive_expp2[4][day][timenum / day] = {
	{
		{18.38666667,16.35222222,19.44777778,20.74555556,15.69555556,11.53444444,19.19,18.20555556,16.76111111,20.38111111,12.45333333,14.77111111,21.19444444,19.25,17.38666667,9.357777778,8.6,4.627151425,3.532169346,4.431340715,2.901602257,3.538228823,8.957282019,16.62863302},
{22.97740339,25.06005359,28.24101281,26.69019483,27.6173569,17.57017637,20.07640441,22.61668264,19.31275063,18.47489265,10.85192874,13.15027148,14.35853827,15.6739061,11.01838248,9.712826928,7.727421129,3.857940206,2.954112008,2.930210038,2.494458427,3.908056457,5.303332802,16.20614409},
{17.79645538,20.58871775,23.0574871,23.17690682,20.02434051,17.36036865,19.01663801,20.48540736,17.86215575,17.33092511,14.01996723,14.05123658,17.01267727,16.29394662,13.01983838,10.87826508,10.2476848,5.282222222,4.615555556,4.128333333,9.15,5.880555556,6.954444444,13.44111111},
{13.63277778,20.34666667,27.85555556,25.97944444,20.76555556,23.24444444,30.66777778,18.24833333,12.04722222,10.50444444,11.91055556,13.81666667,16.13722222,8.098333333,14.74833333,10.385,10.70555556,5.976190476,3.46031746,4.579365079,4.357142857,3.793650794,8.5,15.70634921},
{13,17.79365079,22.93650794,23.65079365,22.17460317,19,22.25396825,20.22222222,19.45238095,14.38095238,13.87301587,13.73015873,12.37301587,10.31746032,12.99206349,10.22222222,8.253968254,4.603174603,4.484126984,3.365079365,3.920634921,3.492063492,6.126984127,18.70634921},
{20.37301587,27.37301587,27.25396825,24.12698413,24.23809524,18,20.65079365,20.92063492,17.23015873,16.16666667,10.86507937,10.38888889,15.06349206,12.22222222,9.531746032,9.30952381,5.849206349,5.867149758,1.212560386,3.405797101,3.193236715,5.690821256,9.799516908,18.12077295},
{18.94444444,21.99033816,27.87439614,24.94202899,24.2826087,14.6884058,16.57729469,24.8,19.4057971,17.00966184,11.42995169,15.57487923,15.47342995,22.73671498,13.37198068,8.514492754,6.514492754,5.226666667,4.893333333,5.292222222,2.984444444,3.651111111,6.825555556,15.68166667}
},
	{
		{14.81666667,17.62722222,20.97777778,23.55055556,17.99055556,13.82944444,20.21,18.46055556,20.58611111,15.02611111,12.45333333,12.47611111,16.60444444,14.66,11.52166667,7.572777778,6.305,6.251953405,3.611971326,2.47109319,3.208978495,3.865555556,7.036935484,15.44274194},
{15.31596774,21.78609319,26.55195341,21.62370968,20.26329749,16.63181004,24.32793907,25.36311828,21.75181004,13.74385305,11.56643369,10.81467742,18.2627957,16.52806452,12.49541219,9.129856631,5.82702509,5.84,2.78,3.825,1.7025,4.7,7.0725,22.0875},
{19.425,22.8925,33.9125,29.0125,19.0825,18.5525,24.125,24.875,16.96,15.71,10.2,13.6325,14.0875,14.71,9.9325,6.5275,4.9975,4.422222222,3.205555556,3.758333333,3.15,2.880555556,5.419444444,17.68611111},
{17.35277778,23.54166667,24.10555556,25.46944444,20.50555556,17.01944444,20.95277778,18.35833333,16.47222222,16.79444444,14.80555556,11.66666667,14.87222222,13.10833333,11.55833333,7.625,6.080555556,4.366666667,2.380555556,3.097222222,3.15,3.263888889,6.525,19.45277778},
{14.325,21.61388889,27.34722222,22.39722222,17.53055556,15.58333333,21.38611111,19.57222222,19.5,16.9,13.47777778,12.16111111,11.99444444,10.50555556,8.894444444,7.130555556,5.527777778,4.422222222,3.038888889,3.147222222,3.427777778,1.936111111,5.030555556,19.68611111},
{16.35277778,24.98611111,24.99444444,26.24722222,19.45,17.075,21.06388889,18.96944444,16.19444444,15.51666667,13.63888889,10.88888889,14.59444444,11.33055556,9.280555556,7.958333333,5.302777778,4.448888889,2.837777778,4.241666667,4.463888889,2.807777778,7.882777778,21.88555556},
{20.78944444,29.06555556,24.58222222,30.87333333,24.435,20.01166667,21.90055556,22.845,17.45166667,16.19944444,12.98777778,14.16944444,14.50277778,13.02388889,10.26111111,11.37666667,4.741666667,4.461666667,3.618333333,2.742222222,2.474444444,3.396111111,6.115555556,21.90666667}
},
	{
		{17.03666667,21.56622222,24.84252778,23.39305556,20.89305556,19.52869444,18.62975,20.67230556,18.73436111,15.98761111,16.45008333,13.27336111,18.06769444,14.64275,13.32241667,8.979027778,6.9545,4.035842294,4.676971326,4.733870968,3.400089606,3.541666667,12.08915771,21.95385305},
{23.5515233,21.21998208,23.75806452,21.90815412,22.43996416,15.15681004,21.18682796,21.34811828,15.80958781,16.41218638,14.58198925,15.89023297,15.96057348,17.67473118,14.3015233,9.176523297,6.89202509,6.45125,2.49025,2.7305,2.668,5.33275,4.905,17.09975},
{19.24175,21.18575,26.637,27.874,22.15,21.41625,19.6395,20.63625,20.607,16.14925,16.75475,12.8595,17.8205,14.16225,12.228,7.3855,5.405,4.055555556,2.555555556,3.166666667,2.833333333,3.055555556,5.277777778,13.77777778},
{14.44444444,19.83333333,21.38888889,17.94444444,15.38888889,13.77777778,17.27777778,17.16666667,15.05555556,11.44444444,11.22222222,11.83333333,15.05555556,10.83333333,9.333333333,5,6.055555556,5.127666667,2.542555556,2.709222222,3.72075,5.343388889,6.461,16.92702778},
{17.62325,22.97963889,25.54672222,26.78047222,21.89305556,18.43708333,19.73436111,19.35197222,18.8635,15.14275,17.12827778,14.00711111,15.07419444,11.72430556,9.866444444,7.503555556,5.492027778,3.138888889,2.488888889,2.322222222,2.694444444,1.661111111,3.655555556,15.56111111},
{12.41111111,20.49444444,23.89444444,19.18888889,15.6,14.23333333,18.77222222,16.49444444,13.62777778,11.11666667,9.238888889,11.07222222,15.32777778,12.52222222,8.088888889,6.216666667,4.294444444,5.103138889,1.764777778,2.653666667,3.369388889,5.232277778,6.498527778,18.45155556},
{17.82744444,25.37355556,24.55972222,28.61883333,21.8375,20.50416667,17.95155556,20.62325,18.52366667,14.84694444,15.15427778,14.34044444,16.15427778,15.54463889,11.52661111,7.867916667,4.880916667,5.127666667,3.067083333,2.709222222,2.671694444,5.805861111,5.276305556,16.57566667}
},
	{
		{16.04966667,25.02072222,25.82952778,25.36705556,20.64630556,17.55469444,21.8375,22.64630556,20.95511111,15.49411111,12.74883333,14.50711111,14.85994444,10.20125,10.85491667,11.69327778,5.72075,5.361203405,3.525971326,3.43659319,3.637978495,3.286055556,7.959435484,16.84749194},
{17.50396774,24.27409319,25.23120341,25.40995968,23.12704749,18.28331004,21.97293907,23.07311828,20.27031004,14.98785305,12.07018369,12.63817742,16.0625457,13.92031452,11.74391219,10.43835663,5.86702509,4.994444444,3.321111111,3.101666667,2.7025,4.201111111,5.411388889,19.13472222},
{17.48555556,22.84083333,25.99361111,25.12138889,19.96861111,18.33638889,22.13555556,21.93166667,18.05444444,16.01888889,14.24611111,13.16583333,16.73694444,14.90666667,12.20916667,6.9725,6.023611111,3.949472222,3.776305556,4.794333333,3.72075,3.042555556,6.398944444,16.75386111},
{18.88802778,25.47816667,23.90605556,26.00269444,20.91255556,17.32094444,20.64777778,18.22283333,16.85847222,15.83394444,11.98405556,12.82891667,15.61822222,13.99558333,10.52808333,9.9155,6.263305556,4.411111111,2.958333333,2.956666667,3.295555556,3.011111111,6.081111111,19.995},
{15.35055556,23.62611111,25.80111111,24.56666667,18.64555556,15.41333333,21.10888889,20.77111111,16.52388889,13.22833333,11.22055556,11.55388889,13.46333333,11.16666667,8.040555556,7.427222222,5.078333333,4.410555556,2.96,2.961666667,3.292777778,3.018888889,6.090555556,19.98166667},
{15.35777778,23.60888889,25.78888889,24.56666667,18.65111111,15.40666667,21.10111111,20.76888889,16.52944444,13.23666667,11.22444444,11.56111111,13.44833333,11.16666667,8.039444444,7.424444444,5.083333333,4.801666667,1.563333333,3.35,3.796666667,3.573333333,8.598333333,21.21666667},
{17.97833333,23.22666667,24.56666667,24.79,19.095,16.415,20.21166667,22.11,15.41,14.96333333,11.61333333,12.95333333,13.62333333,16.86166667,10.27333333,8.375,4.355,4.140666667,3.067083333,3.696222222,3.411944444,3.091611111,7.003555556,15.83666667}
}
};
const double miu1 = 5.908;    //医生服务时长参数1
const double miu11 = 0.867;//参数2
const double kuai1[2] = { 8.383,0.5180 };
double prob[12] = { 0.488,0.626,0.739,0.831,0.914,0.938,0.959,0.969,0.978,0.987,0.994 };
int s[4] = { 5,10,13,docnum };
//double Arrive_ratio[day] = { 1,1,1,1,1,1,1 };
double Arrive_ratio[day] = { 1,0.8,1.1,1.2,0.9,1.2,0.8 };

const double vip_Arrive_rate[timenum] = { 0 };  //test

const double miu2 = 6;    //检查台服务速率
const double ning[2] = { 8.061,0.3597 };
const double sheng[2] = { 8.265,0.3229 };
const double xuechang[2] = { 7.119,0.3083 };
const double xueqi[2] = { 7.309,0.7435 };

const int nursenum = 100;      //检查台数量
const double probability1 = 0.5804;     //回流率
const double probability2 = 0.2101;
const double probability = 0.5;
const double threshold = 0.5;    //超时阈值为半小时

const int MaxTotal = 1000;

const int Static_Each_Period = 10;
double Static_Divide[2][Static_Each_Period * timenum] = { 0 };
double Sum_Divide[2][Static_Each_Period * timenum] = { 0 };
int ifcout = 0;

int workhours1[docnum * day] = { 5,5,3,1,0,5,9,7,0,0,16,16,0,0,8,8,8,8,8,8,24,24,24,24,32,28,29,30,30,35,40,40,40,32,32,32,32,32,32,32,48,48,48,48,48,50,51,55,58,59,64,64,48,56,56,56,56,56,56,56,72,72,72,72,72,73,81,76,79,80,80,88,88,80,80,80,80,80,80,80,96,96,96,96,96,97,104,104,104,104,112,112,112,104,104,104,104,104,104,104,120,120,120,121,120,123,124,132,128,128,136,136,136,128,128,128,128,128,128,128,144,144,144,144,144,147,148,156,153,152,144,160,147,160,152,152,152,152,152,152 };
int workhours2[docnum * day] = { 14,13,9,6,6,13,16,16,4,4,24,24,8,4,8,8,8,8,8,8,33,33,33,33,32,37,38,39,39,40,48,48,48,32,32,32,32,32,32,32,57,55,57,56,56,59,60,62,64,64,72,72,53,56,56,56,56,56,56,56,78,81,81,78,80,82,88,85,87,88,80,96,96,80,80,80,80,80,80,80,105,104,104,104,104,106,108,110,111,112,120,120,120,104,104,104,104,104,104,104,126,128,128,130,128,132,133,136,135,135,144,144,144,128,128,128,128,128,128,128,153,150,151,152,152,156,157,160,160,160,153,168,156,168,152,152,152,152,152,152 };
int M[Msli * timenum] = { 0 };
int tempM[timenum] = { 5,5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 5, 5, 5, 5, 4 };

int change_num = 0;
int change_type = 0;
int tmp1[docnum * day] = { 0 };
int tmp2[docnum * day] = { 0 };
int tmp3[Msli * timenum] = { 0 };

int tmpwk1[docnum * day] = { 0 };
int tmpwk2[docnum * day] = { 0 };
int tmpM[Msli * timenum] = { 0 };

int bestwk1[docnum * day] = { 0 };
int bestwk2[docnum * day] = { 0 };
int bestM[Msli * timenum] = { 0 };

double bestvalue = 0;
double wholebest = 0;
double lastvalue = 0;
double workload[slice * timenum] = { 0 };
double totalload = 0;

int rest[day] = { 0 };
int nightshift[day] = { 0 };
int shifts[day] = { 0 };

double avewt[slice * timenum] = { 0 };
double maxgap = 0;
double maxgap2 = 0;
vector<double> solutions;
vector<int> searchtimes;
vector<double> gaps;

double gapp = 0;
PyObject* predict_wt_MMC;
ofstream outFile("test1110out.csv", ofstream::app);
// 初始化python调用
int init_py() {
	Py_SetPythonHome(L"C:/ProgramData/Anaconda3");
	Py_Initialize();
	if (!Py_IsInitialized())
	{
		printf("初始化失败！");
	}
	// 将Python工作路径切换到待调用模块所在目录，一定要保证路径名的正确性
	std::string path = "C:/Users/zhoubo/source/repos/combination0713";//运行文件夹
	std::string path1 = "C:/ProgramData/Anaconda3/Lib/site-packages";//所需要调用的torch库所在文件夹
	std::string chdir_cmd = std::string("sys.path.append(\"") + path + "\")";
	std::string chdir_cmd1 = std::string("sys.path.append(\"") + path1 + "\")";
	const char* cstr_cmd = chdir_cmd.c_str();
	const char* cstr_cmd1 = chdir_cmd1.c_str();
	PyRun_SimpleString("import sys");
	PyRun_SimpleString(cstr_cmd);
	PyRun_SimpleString(cstr_cmd1);

	// PyRun_SimpleString("print (sys.path)");

	// 加载模块
	PyObject* moduleName = PyBytes_FromString("predict_c");
	PyRun_SimpleString("import predict_c");
	PyRun_SimpleString("from predict_c import LSTM");

	PyObject* pModule = PyImport_ImportModule("predict_c");
	if (pModule == NULL) // 加载模块失败
	{
		std::cout << "[ERROR] Python get module failed." << std::endl;
		getchar();
		return 0;
	}
	std::cout << "[INFO] Python get module succeed." << std::endl;

	// 加载模型
	PyObject* pModel = PyObject_GetAttrString(pModule, "importModel");
	PyObject_CallObject(pModel, NULL);

	// 加载模块中的函数
	predict_wt_MMC = PyObject_GetAttrString(pModule, "predict_waiting_time_MMC");


	if (predict_wt_MMC == NULL) // 加载function失败
	{
		std::cout << "[ERROR] Python get function failed." << std::endl;
		getchar();
		return 0;
	}
	std::cout << "[INFO] Python get function succeed." << std::endl;
	//Py_Finalize();      // 释放资源
}
// 实际使用过程中调用
double get_obj_value_ML_PSq(double lambda[], int sol[], int MMM[], bool option = false) {

	clock_t t_ssss = clock();
	// ML的两个FEATURE
	PyObject* PyList_Arr1 = PyList_New(timenum);
	PyObject* PyList_sol1 = PyList_New(timenum);
	PyObject* PyList_M1 = PyList_New(timenum);
	for (int i = 0; i < timenum; i++)
	{
		PyList_SetItem(PyList_Arr1, i, PyFloat_FromDouble(lambda[i]));
		PyList_SetItem(PyList_sol1, i, PyLong_FromLong(long(sol[i])));
		PyList_SetItem(PyList_M1, i, PyLong_FromLong(long(MMM[i])));
		if (option) std::cout << lambda[i] << ",";
	}

	if (option) std::cout << std::endl;

	// 设置参数
	PyObject* args = PyTuple_New(3);       // 2个参数
	PyTuple_SetItem(args, 0, PyList_Arr1);
	PyTuple_SetItem(args, 1, PyList_sol1);
	PyTuple_SetItem(args, 2, PyList_M1);

	PyObject* pRet1;

	// 调用函数`
	try {
		pRet1 = PyObject_CallObject(predict_wt_MMC, args);
	}
	catch (...) {
		for (int i = 0; i < slice * timenum; i++) {
			//cout << lambda[i] << " "<<sol[i]<<" "<<MMM[i]<<endl;
		}
		system("pause");
	}
	/*
	for (int i = 0; i < slice * timenum; i++) {
		outFile << lambda[i] << ",";
	}
	outFile << endl;
	for (int i = 0; i < slice * timenum; i++) {
		outFile << sol[i] << ",";
	}
	outFile << endl;
	for (int i = 0; i < slice * timenum; i++) {
		outFile << MMM[i] << ",";
	}
	outFile << endl;
	*/
	// 获取参数
	if (pRet1 == NULL) {
		for (int i = 0; i < slice * timenum; i++) {
			cout << lambda[i] << " " << sol[i] << " " << MMM[i] << endl;
		}
		system("pause");
		cout << "[ERROR] Python call function failed" << endl;
		return -1;
	}
	if (option) cout << "time_ml: " << (double)(clock() - t_ssss) / CLOCKS_PER_SEC << endl;
	double result1 = PyFloat_AsDouble(pRet1);
	//outFile << result1 << endl;
	result1 = result1 / 10;
	result1 += offset;
	//cout << result1 << endl;

	return result1;

}
//输出上下班时间和M
void printout(int a1[], int a2[], int a3[], int type = 1) {
	for (int i = 0; i < docnum * day; i++) {
		//cout << a1[i] << ' ' << a2[i] << endl;
	}
	int tmpsche[slice * timenum] = { 0 };
	for (int i = 0; i < docnum * day; i++) {
		if (a1[i] == 0) {
			tmpsche[0]++;
		}
	}
	for (int i = 1; i < slice * timenum; i++) {
		int tmp = 0;
		for (int j = 0; j < docnum * day; j++) {
			if (a1[j] == i) {
				tmp = tmp + 1;
			}
			if (a2[j] == i) {
				tmp = tmp - 1;
			}
		}
		tmpsche[i] = tmpsche[i - 1] + tmp;
	}
	cout << "上班时间：";
	for (int i = 0; i < docnum * day; i++) {
		cout << a1[i] << ',';
	}
	cout << endl;
	cout << "下班时间：";
	for (int i = 0; i < docnum * day; i++) {
		cout << a2[i] << ',';
	}
	cout << endl;
	cout << "M：";
	for (int i = 0; i < Msli * timenum; i++) {
		cout << a3[i] << ',';
	}
	cout << endl;
	cout << "医生数：";
	for (int i = 0; i < slice * timenum; i++) {
		cout << tmpsche[i] << ',';
	}
	cout << endl;
	if (type != 1) {
		outFile << "上班时间：";
		for (int i = 0; i < docnum * day; i++) {
			outFile << a1[i] << ',';
		}
		outFile << endl;
		outFile << "下班时间：";
		for (int i = 0; i < docnum * day; i++) {
			outFile << a2[i] << ',';
		}
		outFile << endl;
		outFile << "M：";
		for (int i = 0; i < Msli * timenum; i++) {
			outFile << a3[i] << ',';
		}
		outFile << endl;
		outFile << "医生数：";
		for (int i = 0; i < slice * timenum; i++) {
			outFile << tmpsche[i] << ',';
		}
		outFile << endl;
	}
}

class Patient  //病人类
{
public:
	double arrivetime;   //到达时间
	double lasttime;   //在医生处开始排队的时间，用于统计这个病人的等待时间
	double ons_waittime = 0;   //等待时间加和
	double FCFS_time;   //进入医生、检查台、大厅队列的时间，用于确定排队先来后到的优先级
	int _intari;   //到达时间的整数，用于统计
	int belongdoc;   //从哪个医生出来的，用于回流
	bool first_come = true;    //是否第一次看医生
	int vip; //高等级为1,低等级为2
	int first_check = 0;

	Patient(double ari_t, double lst_t, int int_ari, int vi_p) : arrivetime(ari_t), lasttime(lst_t), _intari(int_ari), vip(vi_p) {}
};

struct patient_compare //先比较优先等级，在比较先来后到
{
	bool operator()(const Patient& a, const Patient& b)//is  a等级比b等级低 && is a比b晚到—>得到 is a比b晚接受服务。 均同 a前
	{
		if (a.vip != b.vip)return a.vip > b.vip;
		else return a.FCFS_time > b.FCFS_time;
	}
};

class Doctor
{
public:
	priority_queue<Patient, vector<Patient>, patient_compare> Doc_que;
	int internal = 0;   //内队列多少人了
	int vip_num = 0;   //vip病人数量
	bool on_duty = 0;  //暂时没用上
	double next_finish_time = DBL_MAX;   //下一个事件发生的时间
	int workhour1;
	int workhour2;
};

class Nurse
{
public:
	priority_queue<Patient, vector<Patient>, patient_compare> Nur_que;
	//队列中人数通过对优先级队列的统计得到。
	int vip_num = 0; //vip病人数量
	double next_finish_time = DBL_MAX;
};

struct Event
{
public:
	double time;
	int what_type;    //-2代表普通病人到达，-1代表vip病人到达,和vip等级相对应，0代表医生处理完，1代表检查台
	int which;   //-1则代表是病人来了，无意义,其他则代表是哪个医生/检查台将要完成服务

	Event(double t, int _what, int _which) : time(t), what_type(_what), which(_which) {}
};

struct event_time_compare  //小顶堆，时间早的优先
{
	bool operator()(const Event& a, const Event& b)//is b在前  同时间的话a在前
	{
		return a.time > b.time;
	}
};

int common_Findmininter(Doctor* Doctors, double modtnow)   //找最小队长医生小函数
{
	int min = 100000;//内队列人数
	int which_inter = -1;
	if (nowtype == 0) {
		for (int i = 0; i < Schedule[(int)floor(modtnow)]; i++)
		{
			if (Doctors[i].internal <= min) { min = Doctors[i].internal; which_inter = i; }
		}
		if (which_inter >= docnum * day) {
			//cout << "error ajkhkjdha " << endl; system("pause");
		}
	}
	else {
		for (int i = 0; i < docnum * day; i++) {
			if (Doctors[i].workhour1 <= (int)floor(modtnow) && Doctors[i].workhour2 > (int)floor(modtnow)) {

				//cout << Doctors[i].workhour1 << endl;
				if (Doctors[i].internal < min) {
					min = Doctors[i].internal;
					which_inter = i;
				}
			}
		}
	}
	//cout << Schedule[(int)floor(modtnow)] << which_inter << endl;;
	if (which_inter == -1) {
		for (int i = 0; i < docnum * day; i++) {
			cout << i << " " << Doctors[i].internal << endl;
		}
		cout << modtnow << " wrong" << endl;
		system("pause");
	}
	return which_inter;
}

int common_Findminnur(Nurse* Nurses, const int nursenum)   //找最小队长检查台小函数
{
	int min = 100000;
	int minnur = -1;
	for (int i = 0; i < nursenum; i++)
	{
		if (Nurses[i].Nur_que.size() < min) { min = (int)Nurses[i].Nur_que.size(); minnur = i; }
	}
	if (minnur == -1) {
		cout << "wrong in nurse" << endl;
		system("pause");
	}
	return minnur;
}

int vip_Find_min_inter(Doctor* Doctors, double modtnow) //找最小vip病人 & 且未满 医生
{
	int min = INT_MAX;
	int which_inter = -1;
	int j = (int)floor(modtnow);
	for (int i = 0; i < Schedule[j]; i++)
	{
		if (Doctors[i].internal < M[j] && Doctors[i].vip_num < min) { min = Doctors[i].internal; which_inter = i; }
	}
	return which_inter;//to do 如果医生数均为满，则返回值不可控。
}

int vip_Find_min_nur(Nurse* Nurses, const int nursenum)//找最小vip病人数量的检查台  //to do 会不是检查台的优先级引入导致的问题？
{
	int min = Nurses[0].vip_num;
	int minnur = 0;
	for (int i = 1; i < nursenum; i++)
	{
		if (Nurses[i].vip_num < min) { min = Nurses[i].vip_num; minnur = i; }
	}
	return minnur;
}
//1为到下班时间看完当前病人即走
double Run_Case_Manager_1(int Schedule[], int M[], int Circle = totalday)
{
	for (int i = 0; i < slice * timenum; i++) {
		workload[i] = 0;
	}
	totalload = 0;
	::std::mt19937 rng(1);
	//::std::mt19937 rng(time(NULL));
	cout << "开始仿真1" << endl;
	//std::exponential_distribution<double> doc_expo(miu1);//?
	uniform_real_distribution<double>check(0, 1);
	lognormal_distribution<double>doc_log(miu1, miu11);
	//std::exponential_distribution<double> nur_expo(miu2);//?
	lognormal_distribution<double>ning_log(ning[0], ning[1]);
	lognormal_distribution<double>sheng_log(sheng[0], sheng[1]);
	lognormal_distribution<double>xueqi_log(xueqi[0], xueqi[1]);

	const gsl_rng_type* T;
	gsl_rng* r;
	gsl_rng_env_setup();
	T = gsl_rng_default;
	r = gsl_rng_alloc(T);

	int maxdocnum = 0;//寻找现行排班方案最大医生数量
	for (int i = 0; i < slice * timenum; i++)
	{
		if (Schedule[i] > maxdocnum) maxdocnum = Schedule[i];
	}
	double tnow = 0;
	double modtnow = 0;
	double common_Sumwaittime[slice * timenum] = { 0 };  //普通病人： 等待时间统计
	int common_Sumwaitnum[slice * timenum] = { 0 };      //普通病人： 可统计每小时到达系统的人数
	int common_Overtimenum[slice * timenum] = { 0 };     //普通病人： 第一次看到医生超时的病人数

	double vip_Sumwaittime[slice * timenum] = { 0 };
	int vip_Sumwaitnum[slice * timenum] = { 0 };
	int vip_Overtimenum[slice * timenum] = { 0 };
	double totaltime = 0;
	int totalnum = 0;
	double avgwaittime = 0;

	int countFailIn[2] = { 0 };
	int countcheck = 0;
	Nurse Nurses[nursenum];
	Doctor* Doctors = new Doctor[maxdocnum];

	priority_queue<Patient, vector<Patient>, patient_compare> Pre_queue;   //病人队列
	priority_queue<Event, vector<Event>, event_time_compare> events_que;   //时间队列

	//事件驱动的仿真规则：先生成所有病人到达时间，然后每个医生或检查台开始服务就生成一个这个病人服务完的时间，用一个函数取病人到达、医生服务完病人、检查台服务完病人中最早发生的那个作为下一个事件。以此驱动代码运行

	for (int round = 1; round <= Circle; round++) //仿真正式开始，连续进行round天
	{
		//cout << "test5" << endl;

		for (int i = 0; i < timenum; i++)  //一天的开始，先把当天所有普通病人到达的事件先塞进队
		{
			std::uniform_real_distribution<double> uni(timenum * ((double)round - 1) + i, timenum * ((double)round - 1) + i + 1);
			std::poisson_distribution<int> poi(Arrive_rate[i]);
			int size = poi(rng);// 使用rng引擎获得poi分布
			for (int j = 1; j <= size; j++)  //生成size个均匀分布时刻
			{
				Event p_ari(uni(rng), -2, -1);//  到达时间- 普通病人- 新来
				events_que.push(p_ari);//加入事件列
			}
		}
		/*
		for (int i = 0; i < timenum; i++)  //再塞vip病人---先后顺序对结果有0.5%影响-- 随着仿真次数增加而减少
		{
			std::uniform_real_distribution<double> vip_uni(timenum * (round - 1) + i, timenum * (round - 1) + i + 1);
			std::poisson_distribution<int> poi(vip_Arrive_rate[i]);
			int size = poi(rng);
			for (int j = 1; j <= size; j++)  //生成size个均匀分布时刻
			{
				Event vip_ari(vip_uni(rng), -1, -1);//  到达时间- 高级病人- 新来
				events_que.push(vip_ari);//加入事件列
			}
		}
		*/
		while (1)
		{
			//cout << "test6" << endl;
			//瞬态坍缩
			while (!Pre_queue.empty()) //大厅队列还有人在排着呢（t now 瞬间 外队列向内队列的坍缩）
			{
				//std::cout << count++ << endl;
				//cout << "test10 : " << Pre_queue.size() << endl;
				int min_internal = common_Findmininter(Doctors, slice * modtnow);//定位最小医生

				if (Doctors[min_internal].internal >= M[(int)floor(Msli * modtnow)]) break;  //所有医生内队列都超过阈值，病人进入大厅队列

				if (Pre_queue.top().vip == 1)  //区分，因为普通病人和vip病人的入队选择机制不太一样
				{
					min_internal = vip_Find_min_inter(Doctors, slice * modtnow);
					Doctors[min_internal].vip_num++;
				}

				if (Doctors[min_internal].Doc_que.size() == 0)   //医生处没有人排队，可以直接生成这个病人被服务完的时间节点作为事件
				{
					Patient temp = Pre_queue.top();
					Pre_queue.pop();//病人删除

					temp.FCFS_time = tnow;   //病人是在tnow进入了队列

					if ((tnow - temp.arrivetime) > threshold)
					{
						if (temp.vip == 1) {
							vip_Overtimenum[temp._intari]++;  //初次等待时间超过阈值了
							//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
						}
						else {
							common_Overtimenum[temp._intari]++;
							//Static_Divide[1][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
						}
					}
					temp.first_come = false;
					temp.ons_waittime += tnow - temp.lasttime;  //这次它等了多久

					Doctors[min_internal].Doc_que.push(temp);
					Doctors[min_internal].internal++;
					Doctors[min_internal].next_finish_time = tnow + doc_log(rng) / 3600;  //代表这个医生服务完这个病人的时间

				}
				else if (Doctors[min_internal].Doc_que.size() != 0)   //前面有人排着，简单进队
				{
					Patient temp = Pre_queue.top();
					Pre_queue.pop();

					temp.FCFS_time = tnow;

					if (Doctors[min_internal].Doc_que.top().vip == 2 && temp.vip == 1)   //抢占规则   12.21wxt修改
					{
						Doctors[min_internal].next_finish_time = tnow + doc_log(rng) / 3600; //由于抢占了，更新服务完病人的时间  //这个更新可无
						if ((tnow - temp.arrivetime) > threshold)
						{
							vip_Overtimenum[temp._intari]++;
							//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
						}
						temp.first_come = false;
						temp.ons_waittime += tnow - temp.lasttime;  //这次它等了多久
						//医生队头普病，大厅队头vip病人，抢占
					//被插队病人进入等待状态，其lasttime需要更新？ debug
					}
					Doctors[min_internal].Doc_que.push(temp);
					Doctors[min_internal].internal++;
				}
			}

			double temp_time = DBL_MAX;
			int temp_type = -5;
			int temp_which = -5;
			if (!events_que.empty())
			{
				temp_time = events_que.top().time;
				temp_type = events_que.top().what_type;
				temp_which = events_que.top().which;
			}
			for (int i = 0; i < maxdocnum; i++)
			{
				if (Doctors[i].next_finish_time < temp_time)
				{
					temp_time = Doctors[i].next_finish_time;
					temp_type = 0;
					temp_which = i;//定位最小的下次时间医生。
				}
			}
			for (int i = 0; i < nursenum; i++)
			{
				if (Nurses[i].next_finish_time < temp_time)
				{
					temp_time = Nurses[i].next_finish_time;
					temp_type = 1;
					temp_which = i;//定位最近的检查台
				}
			}
			//由此得到最近的事件节点

			Event temp_thing(temp_time, temp_type, temp_which);  //代表了下一个事件时病人到达还是医生看完病人还是检查台看完病人？
			if (Doctors[0].Doc_que.size() != 0 && Doctors[0].next_finish_time == DBL_MAX) {
				cout << "当前时间：" << temp_time << " 修正：" << modtnow << " 种类：" << temp_type << " 哪里：" << temp_which <<
					" 0的人数：" << Doctors[0].internal << " 0的下一时间：" << Doctors[0].next_finish_time << " 0的队长：" << Doctors[0].Doc_que.size() <<
					" 外队列长：" << Pre_queue.size() << endl;
			}

			if (ifcout == 1) {
				cout << "当前时间：" << temp_time << " 修正：" << modtnow << " 种类：" << temp_type << " 哪里：" << temp_which <<
					" 0的人数：" << Doctors[0].internal << " 0的下一时间：" << Doctors[0].next_finish_time << " 0的队长：" << Doctors[0].Doc_que.size() <<
					" 外队列长：" << Pre_queue.size() << endl;
			}
			if (temp_thing.time == DBL_MAX || temp_thing.time >= (timenum * (double)round))  break;   //没有下一个事件或者到事件到第二天了
			//cout << "test1:" <<tnow<< endl;
			//应该先完成不可能状态到可能状态的转移，再进行时间的更新
			tnow = temp_thing.time; //更新仿真时钟
			modtnow = tnow - timenum * ((double)round - 1);

			if (temp_thing.what_type == -2) //普通病人到达分支开始
			{
				if (Pre_queue.size() >= MaxTotal) {

					common_Sumwaitnum[(int)floor(slice * modtnow)]++;   //这里统计每小时到达人数
					common_Overtimenum[(int)floor(slice * modtnow)]++;
					//Static_Divide[1][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					//Sum_Divide[1][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					events_que.pop();

					countFailIn[1]++;

					continue;
				}

				events_que.pop();

				Patient newpatient(tnow, tnow, (int)floor(slice * modtnow), 2);
				newpatient.FCFS_time = tnow;
				common_Sumwaitnum[(int)floor(slice * modtnow)]++;   //这里统计每小时到达人数

				//Sum_Divide[1][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;

				int min_internal = common_Findmininter(Doctors, slice * modtnow);
				if (Doctors[min_internal].internal >= M[(int)floor(Msli * modtnow)]) Pre_queue.push(newpatient);   //最小内队列无位置则大厅等候
				else   //反之进医生队
				{
					if (Doctors[min_internal].Doc_que.size() == 0)
					{
						Doctors[min_internal].next_finish_time = tnow + doc_log(rng) / 3600;
						newpatient.first_come = false;
					}
					Doctors[min_internal].Doc_que.push(newpatient);
					Doctors[min_internal].internal++;
				}
			}  //病人到达分支结束

			if (temp_thing.what_type == -1)  //vip病人到达
			{
				if (Pre_queue.size() >= MaxTotal) {

					vip_Sumwaitnum[(int)floor(slice * modtnow)]++;   //这里统计每小时到达人数
					vip_Overtimenum[(int)floor(slice * modtnow)]++;
					//Static_Divide[0][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					//Sum_Divide[0][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					events_que.pop();

					countFailIn[0]++;

					continue;
				}

				events_que.pop();

				Patient newpatient(tnow, tnow, (int)floor(slice * modtnow), 1);
				newpatient.FCFS_time = tnow;
				vip_Sumwaitnum[newpatient._intari]++;   //分开统计两类病人每小时达到的数量
				//Sum_Divide[0][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;

				int min_internal = common_Findmininter(Doctors, slice * modtnow);

				if (Doctors[min_internal].internal >= M[(int)floor(Msli * modtnow)]) Pre_queue.push(newpatient);
				else
				{
					min_internal = vip_Find_min_inter(Doctors, slice * modtnow);
					if (Doctors[min_internal].Doc_que.size() == 0 || Doctors[min_internal].Doc_que.top().vip == 2) //没人，或者是普通病人在队头，可以插队一下
					{
						Doctors[min_internal].next_finish_time = tnow + doc_log(rng) / 3600;
						newpatient.first_come = false;
					}
					Doctors[min_internal].Doc_que.push(newpatient);
					Doctors[min_internal].internal++;
					Doctors[min_internal].vip_num++;
					//被插队病人进入等待状态，其lasttime需要更新？ debug
				}
			}

			if (temp_thing.what_type == 0)   //医生分支开始
			{

				int y = temp_thing.which; //y就是哪个医生服务完病人了
				//cout << y << endl;

				double temp1 = Doctors[y].next_finish_time;
				if (Doctors[y].Doc_que.size() == 0) {
					cout << y << endl;
					cout << temp1 << endl;
					cout << modtnow << endl;
					cout << tnow << endl;
					cout << Schedule[(int)floor(slice * modtnow)] << endl;
					system("pause");
				}
				Doctors[y].next_finish_time = DBL_MAX;  //重置这个医生的下一个事件时间

				std::uniform_real_distribution<double> distribution(0, 1);
				double p = distribution(rng);
				int tmp11 = Doctors[y].Doc_que.top().first_check;
				if ((p <= probability1 && tmp11 == 0) || (p < probability2 && tmp11 == 1))    //病人外部检查
				{
					Patient temp = Doctors[y].Doc_que.top();
					temp.FCFS_time = tnow;
					temp.belongdoc = y;

					int minnur;   //代表了这个病人要去的检查台
					if (temp.vip == 1)
					{
						//minnur = vip_Find_min_nur(Nurses, nursenum);
						minnur = common_Findminnur(Nurses, nursenum);
						Nurses[minnur].vip_num++;
					}
					else if (temp.vip == 2)
					{
						minnur = common_Findminnur(Nurses, nursenum);   //找一下病人要进哪一个检查台队列
					}
					double chech = check(rng);
					double checktime = 0;
					if (chech < prob[0]) {
						checktime = max(ning_log(rng), max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0])));
					}
					else if (chech < prob[1]) {
						checktime = exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0]);
					}
					else if (chech < prob[2]) {
						checktime = max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0]));
					}
					else if (chech < prob[3]) {
						checktime = sheng_log(rng);
					}
					else if (chech < prob[4]) {
						checktime = max(max(ning_log(rng), xueqi_log(rng)), max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0])));
					}
					else if (chech < prob[5]) {
						checktime = max(ning_log(rng), sheng_log(rng));
					}
					else if (chech < prob[6]) {
						checktime = max(ning_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0]));;
					}
					else if (chech < prob[7]) {
						checktime = xueqi_log(rng);
					}
					else if (chech < prob[8]) {
						checktime = max(xueqi_log(rng), max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0])));
					}
					else if (chech < prob[9]) {
						checktime = ning_log(rng);
					}
					else if (chech < prob[10]) {
						checktime = max(xueqi_log(rng), sheng_log(rng));
					}
					else {
						checktime = exp(gsl_ran_logistic(r, kuai1[1]) + kuai1[0]);
					}
					if (Nurses[minnur].Nur_que.empty())
						Nurses[minnur].next_finish_time = tnow + checktime / 3600;
					else if (Nurses[minnur].Nur_que.top().vip == 2 && temp.vip == 1) //抢占
					{
						Nurses[minnur].next_finish_time = tnow + checktime / 3600;
					}
					Nurses[minnur].Nur_que.push(temp);

					if (Nurses[minnur].Nur_que.size() > 1) { cout << "warning hakjhkj " << endl; }

					Doctors[y].Doc_que.pop();

					if (Doctors[y].Doc_que.size() != 0) //前一个病人刚走，还有人在排队，那下一个
					{
						if (y < Schedule[(int)floor(slice * modtnow)]) {
							Patient temp = Doctors[y].Doc_que.top();
							Doctors[y].Doc_que.pop();

							if (temp.first_come == true) //病人是第一次看到医生，记录是否超时并置firstcome属性为false
							{
								temp.ons_waittime = temp.ons_waittime + tnow - temp.arrivetime;
								if ((tnow - temp.arrivetime) > threshold)
								{
									if (temp.vip == 1) {
										vip_Overtimenum[temp._intari]++;  //初次等待时间超过阈值了
										//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
									}
									else {
										common_Overtimenum[temp._intari]++;
										//Static_Divide[1][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
									}
								}
								temp.first_come = false;
							}
							else {
								temp.ons_waittime += tnow - temp.lasttime;
							}

							Doctors[y].Doc_que.push(temp);
							Doctors[y].next_finish_time = tnow + doc_log(rng) / 3600;
						}
						else {
							while (Doctors[y].Doc_que.size() != 0) {
								Patient tmp = Doctors[y].Doc_que.top();
								Doctors[y].Doc_que.pop();
								Doctors[y].internal--;
								tmp.FCFS_time = tnow;
								int tmpnum = common_Findmininter(Doctors, slice * modtnow);
								if (Doctors[tmpnum].Doc_que.size() == 0) {
									Doctors[tmpnum].next_finish_time = tnow + doc_log(rng) / 3600;
									if (tmp.first_come == true) {
										tmp.first_come = false;
										tmp.ons_waittime = tmp.ons_waittime + tnow - tmp.arrivetime;
									}
								}
								Doctors[tmpnum].Doc_que.push(tmp);
								Doctors[tmpnum].internal++;
							}
							Doctors[y].next_finish_time = DBL_MAX;
						}
					}
					else {
						Doctors[y].next_finish_time = DBL_MAX;
					}
				}
				else   //病人离开系统
				{
					//cout << "test1" << endl;
					//离开部分
					if (Doctors[y].Doc_que.top().vip == 1) Doctors[y].vip_num--;

					if (Doctors[y].Doc_que.top().vip == 1)
						vip_Sumwaittime[Doctors[y].Doc_que.top()._intari] += Doctors[y].Doc_que.top().ons_waittime;//离开病人的总等待时间
					else {
						common_Sumwaittime[Doctors[y].Doc_que.top()._intari] += Doctors[y].Doc_que.top().ons_waittime;//离开病人的总等待时间
						if (ifcout == 2) {
							cout << tnow << " " << modtnow << " " << Doctors[y].Doc_que.top().ons_waittime << " " << Doctors[y].Doc_que.top().first_check << " " << Pre_queue.size() << endl;
							//cout << "当前时间：" << temp_time << " 修正：" << modtnow << " 种类：" << temp_type << " 哪里：" << temp_which <<
								//" 0的人数：" << Doctors[0].internal << " 0的下一时间：" << Doctors[0].next_finish_time << " 0的队长：" << Doctors[0].Doc_que.size() <<
								//" 外队列长：" << Pre_queue.size() << endl;
						}

					}

					if (Doctors[y].Doc_que.empty()) {
						cout << "出大事儿了" << endl;
						cout << y << "  " << temp1 << endl;
						cout << "error ahjkh1 " << Doctors[0].next_finish_time << endl;
						cout << "error ahjkh1 " << Doctors[1].next_finish_time << endl;

						cout << "error ahjkh1 " << Doctors[0].internal << endl;
						cout << "error ahjkh1 " << Doctors[1].internal << endl;
						cout << "error ahjkdaaah1 " << Doctors[0].Doc_que.size() << endl;
						cout << "error ahjkdaaah1 " << Doctors[1].Doc_que.size() << endl;
						cout << "error ahjkdaaahss1 " << Pre_queue.size() << endl;

						system("pause");
					}

					Doctors[y].Doc_que.pop();  //医生外队列出队
					Doctors[y].internal--;   //内队列-1
					Doctors[y].next_finish_time = DBL_MAX;
					if (Doctors[y].internal == 0) {

					}
					if (Doctors[y].internal < 0) {//|| Doctors[y].internal>4
						cout << tnow << endl;
						cout << modtnow << endl;
						cout << "error ahjkh2 " << Doctors[0].internal << endl;
						cout << "error ahjkh2 " << Doctors[1].internal << endl;
						cout << "error ahjkdaaah2 " << Doctors[0].Doc_que.size() << endl;
						cout << "error ahjkdaaah2 " << Doctors[1].Doc_que.size() << endl;
						cout << "error ahjkdaaahss2 " << Pre_queue.size() << endl;

					}

					//if (Doctors[y].Doc_que.size() != 0)   //医生为下一个病人看病(瞬间被服务到了）
					if ((Doctors[y].Doc_que.size() != 0 && Doctors[y].Doc_que.top().vip == 1)//debug位置
						|| (Doctors[y].Doc_que.size() != 0 && Pre_queue.empty())
						|| (Doctors[y].Doc_que.size() != 0 && Pre_queue.top().vip != 1)
						)   //医生为内队列下一个病人看病 1 下一病人为高等级 2 下一病人为低等级但外队列没有高等级
					{
						//cout << "test3" << endl;
						if (y < Schedule[(int)floor(slice * modtnow)]) {
							Patient temp = Doctors[y].Doc_que.top();
							Doctors[y].Doc_que.pop();

							if (temp.first_come == true) //病人是第一次看到医生，记录是否超时并置firstcome属性为false
							{
								temp.ons_waittime += tnow - temp.arrivetime;
								if ((tnow - temp.arrivetime) > threshold)
								{
									if (temp.vip == 1) {
										vip_Overtimenum[temp._intari]++;  //初次等待时间超过阈值了
										//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
									}
									else {
										common_Overtimenum[temp._intari]++;
										//Static_Divide[1][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
									}
								}
								temp.first_come = false;
							}
							else {
								temp.ons_waittime += tnow - temp.lasttime;// to do  lasttime需要更新吗
							}

							Doctors[y].Doc_que.push(temp);
							Doctors[y].next_finish_time = tnow + doc_log(rng) / 3600;
						}
						else {
							while (Doctors[y].Doc_que.size() != 0) {
								Patient tmp = Doctors[y].Doc_que.top();
								Doctors[y].Doc_que.pop();
								Doctors[y].internal--;
								tmp.FCFS_time = tnow;
								int tmpnum = common_Findmininter(Doctors, slice * modtnow);
								if (Doctors[tmpnum].Doc_que.size() == 0) {
									Doctors[tmpnum].next_finish_time = tnow + doc_log(rng) / 3600;
									if (tmp.first_come == true) {
										tmp.first_come = false;
										tmp.ons_waittime += tnow - tmp.arrivetime;
									}
								}
								Doctors[tmpnum].Doc_que.push(tmp);
								Doctors[tmpnum].internal++;
							}
							Doctors[y].next_finish_time = DBL_MAX;
						}
					}
					else if (Doctors[y].Doc_que.size() != 0 && !Pre_queue.empty() && Pre_queue.top().vip == 1)// 内队列没有高等级，且外队列有高等级。 （外队列高等级插入进来）
					{


					}
					else if (Doctors[y].Doc_que.size() != 0) {
						cout << "error hjkhakh" << endl;
					}
					else
					{
						Doctors[y].next_finish_time = DBL_MAX;
					}

					//cout << "test2" << endl;

				}   //病人离开系统分支结束
			}   //医生分支结束

			if (temp_thing.what_type == 1)  //检查台分支开始
			{
				countcheck++;
				int y = temp_thing.which;  //是哪一个检查台？
				Nurses[y].next_finish_time = DBL_MAX;
				Patient temp = Nurses[y].Nur_que.top();
				temp.first_check++;
				if (temp.vip == 1) Nurses[y].vip_num--;
				Nurses[y].Nur_que.pop();
				temp.lasttime = tnow; //更新病人的lasttime，因为他马上要回到医生处排队了，需要统计新一轮的等待时间
				temp.FCFS_time = tnow;
				if (temp.belongdoc >= Schedule[(int)floor(slice * modtnow)]) {
					Doctors[temp.belongdoc].internal--;
					temp.belongdoc = common_Findmininter(Doctors, slice * modtnow);
					Doctors[temp.belongdoc].internal++;
				}
				if (Doctors[temp.belongdoc].Doc_que.size() == 0)
					Doctors[temp.belongdoc].next_finish_time = tnow + doc_log(rng) / 3600;  //没人排队，直接生成服务完时间
				else if (Doctors[temp.belongdoc].Doc_que.top().vip == 2 && temp.vip == 1) //抢占
				{
					Doctors[temp.belongdoc].next_finish_time = tnow + doc_log(rng) / 3600;
				}

				Doctors[temp.belongdoc].Doc_que.push(temp);  //病人回到原来的医生处

				if (!Nurses[y].Nur_que.empty()) {
					double chech = check(rng);
					double checktime = 0;
					if (chech < prob[0]) {
						checktime = max(ning_log(rng), max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0])));
					}
					else if (chech < prob[1]) {
						checktime = exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0]);
					}
					else if (chech < prob[2]) {
						checktime = max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0]));
					}
					else if (chech < prob[3]) {
						checktime = sheng_log(rng);
					}
					else if (chech < prob[4]) {
						checktime = max(max(ning_log(rng), xueqi_log(rng)), max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0])));
					}
					else if (chech < prob[5]) {
						checktime = max(ning_log(rng), sheng_log(rng));
					}
					else if (chech < prob[6]) {
						checktime = max(ning_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0]));;
					}
					else if (chech < prob[7]) {
						checktime = xueqi_log(rng);
					}
					else if (chech < prob[8]) {
						checktime = max(xueqi_log(rng), max(sheng_log(rng), exp(gsl_ran_logistic(r, xuechang[1]) + xuechang[0])));
					}
					else if (chech < prob[9]) {
						checktime = ning_log(rng);
					}
					else if (chech < prob[10]) {
						checktime = max(xueqi_log(rng), sheng_log(rng));
					}
					else {
						checktime = exp(gsl_ran_logistic(r, kuai1[1]) + kuai1[0]);
					}
					Nurses[y].next_finish_time = tnow + checktime / 3600;
				}
			}  //检查台分支结束
		}
	}

	//清空内存
	while (!Pre_queue.empty()) Pre_queue.pop();
	for (int i = 0; i < maxdocnum; i++) { while (!Doctors[i].Doc_que.empty()) Doctors[i].Doc_que.pop(); }
	for (int i = 0; i < nursenum; i++) { while (!Nurses[i].Nur_que.empty()) Nurses[i].Nur_que.pop(); }
	delete[]Doctors;
	while (!events_que.empty()) events_que.pop();
	int totalover = 0;
	double sumnum[7] = { 0 };
	double sumwait[7] = { 0 };
	for (int i = 0; i < slice * timenum; i++)
	{
		totalnum += common_Sumwaitnum[i];
		totaltime += common_Sumwaittime[i];
		totalover += common_Overtimenum[i];
		avewt[i] = common_Sumwaittime[i] / totalday;
		cout << common_Sumwaittime[i] / common_Sumwaitnum[i] << endl;
		sumnum[i / 24] += common_Sumwaitnum[i];
		sumwait[i / 24] += common_Sumwaittime[i];
		//cout << "第" << i << "时段普通到达人数：" << common_Sumwaitnum[i] << "    服务水平:" << 1 - (double)common_Overtimenum[i] / (double)common_Sumwaitnum[i] << "    等待时间:" << common_Sumwaittime[i] / (double)common_Sumwaitnum[i] << endl;
	}
	for (int i = 0; i < 7; i++) {
		cout << sumwait[i] / sumnum[i] << endl;
	}
	for (int i = 0; i < timenum; i++)
	{
		//cout << common_Sumwaitnum[i] << " " << Arrive_rate[i] << endl;
		//cout << "第" << i << "时段vip到达人数：" << vip_Sumwaitnum[i] << "    服务水平:" << 1 - (double)vip_Overtimenum[i] / (double)vip_Sumwaitnum[i] << "    等待时间:" << vip_Sumwaittime[i] / (double)vip_Sumwaitnum[i] << endl;
	}

	int count[2] = { 0 };

	for (int i = 0; i < timenum; i++) {
		//cout << "第" << i << "时段普通到达人数：" << endl;
		for (int s = 0; s < Static_Each_Period; s++)
		{
			//cout << "第" << double(i) + double(s) / double(Static_Each_Period) << "小时段普通到达人数:" << Sum_Divide[1][i * Static_Each_Period + s] << "    服务水平:" << 1 - (double)Static_Divide[1][i * Static_Each_Period + s] / (double)Sum_Divide[1][i * Static_Each_Period + s] << endl;
		}
	}

	for (int i = 0; i < timenum; i++) {
		//cout << "第" << i << "时段普通到达人数：" << endl;
		for (int s = 0; s < Static_Each_Period; s++)
		{
			//cout << "第" << double(i) + double(s) / double(Static_Each_Period) << "小时段高等级到达人数:" << Sum_Divide[0][i * Static_Each_Period + s] << "    服务水平:" << 1 - (double)Static_Divide[0][i * Static_Each_Period + s] / (double)Sum_Divide[0][i * Static_Each_Period + s] << endl;
		}
	}

	for (int i = 0; i < timenum; i++) {
		for (int s = 0; s < Static_Each_Period; s++)
		{
			//count[1] += Sum_Divide[1][i * timenum + s];
			//count[0] += Sum_Divide[0][i * timenum + s];
		}
	}

	//cout << totalnum << "  " << count[1] << endl;
	//cout << count[0] << endl;
	//cout << countFailIn[0] << " : " << countFailIn[1] << "  " << count[0] << endl;

	avgwaittime = totaltime / (double)totalnum;
	cout << totaltime << " " << totalnum << " " << avgwaittime << " " << totalover << " " << countcheck << endl;
	return avgwaittime;
}
//2为下班看完内队列病人再走
double Run_Case_Manager_2(int workhours1[], int workhours2[], int Schedule[], int M[], int Circle = totalday)
{
	totalload = 0;
	for (int i = 0; i < slice * timenum; i++) {
		workload[i] = 0;
	}
	::std::mt19937 rng(1);
	cout << "开始仿真2" << endl;
	std::exponential_distribution<double> doc_expo(miu1);//?
	std::exponential_distribution<double> nur_expo(miu2);//?
	int maxdocnum = docnum * day;   //寻找现行排班方案最大医生数量

	double tnow = 0;
	double modtnow = 0;
	double common_Sumwaittime[slice * timenum] = { 0 };  //普通病人： 等待时间统计
	int common_Sumwaitnum[slice * timenum] = { 0 };      //普通病人： 可统计每小时到达系统的人数
	int common_Overtimenum[slice * timenum] = { 0 };     //普通病人： 第一次看到医生超时的病人数

	double vip_Sumwaittime[slice * timenum] = { 0 };     //优先病人： 等待时间统计
	int vip_Sumwaitnum[slice * timenum] = { 0 };         //优先病人： 可统计每小时到达系统的人数
	int vip_Overtimenum[slice * timenum] = { 0 };        //优先病人： 第一次看到医生超时的病人数

	double totaltime = 0;
	int totalnum = 0;
	double avgwaittime = 0;
	int totalover = 0;

	int countFailIn[2] = { 0 };

	Nurse Nurses[nursenum];
	Doctor* Doctors = new Doctor[maxdocnum];
	for (int i = 0; i < maxdocnum; i++) {
		Doctors[i].workhour2 = workhours2[i];
		Doctors[i].workhour1 = workhours1[i];
		//cout <<Doctors[i].workhour1<<" "<< Doctors[i].workhour2 << endl;
	}
	//system("pause");
	priority_queue<Patient, vector<Patient>, patient_compare> Pre_queue;   //病人队列
	priority_queue<Event, vector<Event>, event_time_compare> events_que;   //时间队列

	//事件驱动的仿真规则：先生成所有病人到达时间，然后每个医生或检查台开始服务就生成一个这个病人服务完的时间，用一个函数取病人到达、医生服务完病人、检查台服务完病人中最早发生的那个作为下一个事件。以此驱动代码运行

	for (int round = 1; round <= Circle; round++) //仿真正式开始，连续进行round天
	{
		//cout << "test5" << endl;

		for (int i = 0; i < timenum; i++)  //一天的开始，先把当天所有普通病人到达的事件先塞进队
		{
			std::uniform_real_distribution<double> uni(timenum * ((double)round - 1) + i, timenum * ((double)round - 1) + i + 1);
			std::poisson_distribution<int> poi(Arrive_rate[i]);
			int size = poi(rng);// 使用rng引擎获得poi分布。
			for (int j = 1; j <= size; j++)  //生成size个均匀分布时刻
			{
				Event p_ari(uni(rng), -2, -1);//  到达时间- 普通病人- 新来
				events_que.push(p_ari);//加入事件列
			}
		}
		/*
		for (int i = 0; i < timenum; i++)  //再塞vip病人---先后顺序对结果有0.5%影响-- 随着仿真次数增加而减少
		{
			std::uniform_real_distribution<double> vip_uni(double(timenum) * (round - 1) + i, double(timenum) * (round - 1) + i + 1);
			std::poisson_distribution<int> poi(vip_Arrive_rate[i]);
			int size = poi(rng);
			for (int j = 1; j <= size; j++)  //生成size个均匀分布时刻
			{
				Event vip_ari(vip_uni(rng), -1, -1);//  到达时间- 高级病人- 新来
				events_que.push(vip_ari);//加入事件列
			}
		}
		*/
		while (1)
		{
			//cout << "test6" << endl;
			//瞬态坍缩
			while (!Pre_queue.empty()) //大厅队列还有人在排着呢（t now 瞬间 外队列向内队列的坍缩）
			{
				//std::cout << count++ << endl;
				//cout << "test10 : " << Pre_queue.size() << endl;
				int min_internal = common_Findmininter(Doctors, slice * modtnow);//定位最小医生

				if (Doctors[min_internal].internal >= M[(int)floor(Msli * modtnow)]) break;  //所有医生内队列都超过阈值，病人进入大厅队列

				if (Pre_queue.top().vip == 1)  //区分，因为普通病人和vip病人的入队选择机制不太一样
				{
					min_internal = vip_Find_min_inter(Doctors, slice * modtnow);
					Doctors[min_internal].vip_num++;
				}

				if (Doctors[min_internal].Doc_que.size() == 0)   //医生处没有人排队，可以直接生成这个病人被服务完的时间节点作为事件
				{
					Patient temp = Pre_queue.top();
					Pre_queue.pop();//病人删除

					temp.FCFS_time = tnow;   //病人是在tnow进入了队列

					if ((tnow - temp.arrivetime) > threshold)
					{
						if (temp.vip == 1) {
							vip_Overtimenum[temp._intari]++;  //初次等待时间超过阈值了
							Static_Divide[0][int((temp.arrivetime - double((double)round - 1) * timenum) * double(Static_Each_Period))]++;
						}
						else {
							common_Overtimenum[temp._intari]++;
							//Static_Divide[1][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
						}
					}
					temp.first_come = false;
					temp.ons_waittime += tnow - temp.lasttime;  //这次它等了多久

					Doctors[min_internal].Doc_que.push(temp);
					Doctors[min_internal].internal++;
					Doctors[min_internal].next_finish_time = tnow + doc_expo(rng);  //代表这个医生服务完这个病人的时间

				}
				else if (Doctors[min_internal].Doc_que.size() != 0)   //前面有人排着，简单进队
				{
					Patient temp = Pre_queue.top();
					Pre_queue.pop();

					temp.FCFS_time = tnow;

					if (Doctors[min_internal].Doc_que.top().vip == 2 && temp.vip == 1)   //抢占规则   12.21wxt修改
					{
						Doctors[min_internal].next_finish_time = tnow + doc_expo(rng); //由于抢占了，更新服务完病人的时间  //这个更新可无
						if ((tnow - temp.arrivetime) > threshold)
						{
							vip_Overtimenum[temp._intari]++;
							//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
						}
						temp.first_come = false;
						temp.ons_waittime += tnow - temp.lasttime;  //这次它等了多久
						//医生队头普病，大厅队头vip病人，抢占
					//被插队病人进入等待状态，其lasttime需要更新？ debug


					}
					Doctors[min_internal].Doc_que.push(temp);
					Doctors[min_internal].internal++;
				}
			}

			double temp_time = DBL_MAX;
			int temp_type = -5;
			int temp_which = -5;
			if (!events_que.empty())
			{
				temp_time = events_que.top().time;
				temp_type = events_que.top().what_type;
				temp_which = events_que.top().which;
			}
			for (int i = 0; i < maxdocnum; i++)
			{
				if (Doctors[i].next_finish_time < temp_time)
				{
					temp_time = Doctors[i].next_finish_time;
					temp_type = 0;
					temp_which = i;//定位最小的下次时间医生。
				}
			}

			for (int i = 0; i < nursenum; i++)
			{
				if (Nurses[i].next_finish_time < temp_time)
				{
					temp_time = Nurses[i].next_finish_time;
					temp_type = 1;
					temp_which = i;//定位最近的检查台
				}
			}
			//由此得到最近的事件节点

			Event temp_thing(temp_time, temp_type, temp_which);  //代表了下一个事件时病人到达还是医生看完病人还是检查台看完病人？

			if (temp_thing.time == DBL_MAX || temp_thing.time >= (double(timenum) * round))  break;   //没有下一个事件或者到事件到第二天了

			//应该先完成不可能状态到可能状态的转移，再进行时间的更新
			tnow = temp_thing.time; //更新仿真时钟
			modtnow = tnow - double(timenum) * ((double)round - 1);

			if (temp_thing.what_type == -2) //普通病人到达分支开始
			{
				if (Pre_queue.size() >= MaxTotal) {

					common_Sumwaitnum[(int)floor(slice * modtnow)]++;   //这里统计每小时到达人数
					common_Overtimenum[(int)floor(slice * modtnow)]++;
					//Static_Divide[1][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					//Sum_Divide[1][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					events_que.pop();

					countFailIn[1]++;

					continue;
				}

				events_que.pop();

				Patient newpatient(tnow, tnow, (int)floor(slice * modtnow), 2);
				newpatient.FCFS_time = tnow;
				common_Sumwaitnum[(int)floor(slice * modtnow)]++;   //这里统计每小时到达人数

				//Sum_Divide[1][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;

				int min_internal = common_Findmininter(Doctors, slice * modtnow);
				if (Doctors[min_internal].internal >= M[(int)floor(Msli * modtnow)]) Pre_queue.push(newpatient);   //最小内队列无位置则大厅等候
				else   //反之进医生队
				{
					if (Doctors[min_internal].Doc_que.size() == 0)
					{
						Doctors[min_internal].next_finish_time = tnow + doc_expo(rng);
						newpatient.first_come = false;
					}
					Doctors[min_internal].Doc_que.push(newpatient);
					Doctors[min_internal].internal++;
				}
			}  //病人到达分支结束

			//cout << "test8" << endl;

			if (temp_thing.what_type == -1)  //vip病人到达
			{
				if (Pre_queue.size() >= MaxTotal) {

					vip_Sumwaitnum[(int)floor(slice * modtnow)]++;   //这里统计每小时到达人数
					vip_Overtimenum[(int)floor(slice * modtnow)]++;
					//Static_Divide[0][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					//Sum_Divide[0][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;
					events_que.pop();

					countFailIn[0]++;

					continue;
				}

				events_que.pop();

				Patient newpatient(tnow, tnow, (int)floor(slice * modtnow), 1);
				newpatient.FCFS_time = tnow;
				vip_Sumwaitnum[newpatient._intari]++;   //分开统计两类病人每小时达到的数量
				//Sum_Divide[0][int((tnow - double(round - 1) * timenum) * double(Static_Each_Period))]++;


				int min_internal = common_Findmininter(Doctors, slice * modtnow);

				if (Doctors[min_internal].internal >= M[(int)floor(Msli * modtnow)]) Pre_queue.push(newpatient);
				else
				{
					min_internal = vip_Find_min_inter(Doctors, slice * modtnow);
					if (Doctors[min_internal].Doc_que.size() == 0 || Doctors[min_internal].Doc_que.top().vip == 2) //没人，或者是普通病人在队头，可以插队一下
					{
						Doctors[min_internal].next_finish_time = tnow + doc_expo(rng);
						newpatient.first_come = false;
					}
					Doctors[min_internal].Doc_que.push(newpatient);
					Doctors[min_internal].internal++;
					Doctors[min_internal].vip_num++;
					//被插队病人进入等待状态，其lasttime需要更新？ debug
				}
			}

			//cout << "test9" << endl;

			if (temp_thing.what_type == 0)   //医生分支开始
			{
				int y = temp_thing.which; //y就是哪个医生服务完病人了
				//cout << y << endl;

				double temp1 = Doctors[y].next_finish_time;
				Doctors[y].next_finish_time = DBL_MAX;  //重置这个医生的下一个事件时间

				std::uniform_real_distribution<double> distribution(0, 1);
				double p = distribution(rng);

				if (p <= probability && Doctors[y].Doc_que.top().first_check < maxcheck)    //病人外部检查
				{
					Patient temp = Doctors[y].Doc_que.top();
					temp.FCFS_time = tnow;
					temp.belongdoc = y;

					int minnur;   //代表了这个病人要去的检查台
					if (temp.vip == 1)
					{
						//minnur = vip_Find_min_nur(Nurses, nursenum);
						minnur = common_Findminnur(Nurses, nursenum);
						Nurses[minnur].vip_num++;
					}
					else if (temp.vip == 2)
					{
						minnur = common_Findminnur(Nurses, nursenum);   //找一下病人要进哪一个检查台队列
					}
					if (Nurses[minnur].Nur_que.empty())
						Nurses[minnur].next_finish_time = tnow + nur_expo(rng);
					else if (Nurses[minnur].Nur_que.top().vip == 2 && temp.vip == 1) //抢占
					{
						Nurses[minnur].next_finish_time = tnow + nur_expo(rng);
					}
					Nurses[minnur].Nur_que.push(temp);

					if (Nurses[minnur].Nur_que.size() > 1) { cout << "warning hakjhkj " << endl; }

					Doctors[y].Doc_que.pop();

					if (Doctors[y].Doc_que.size() != 0) //前一个病人刚走，还有人在排队，那下一个
					{
						Patient temp = Doctors[y].Doc_que.top();
						Doctors[y].Doc_que.pop();

						if (temp.first_come == true) //病人是第一次看到医生，记录是否超时并置firstcome属性为false
						{
							temp.ons_waittime += tnow - temp.arrivetime;
							if ((tnow - temp.arrivetime) > threshold)
							{
								if (temp.vip == 1) {
									vip_Overtimenum[temp._intari]++;  //初次等待时间超过阈值了
									//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
								}
								else {
									common_Overtimenum[temp._intari]++;
									//Static_Divide[1][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
								}
							}
							temp.first_come = false;
						}
						else {
							temp.ons_waittime += tnow - temp.lasttime;
						}
						Doctors[y].Doc_que.push(temp);
						Doctors[y].next_finish_time = tnow + doc_expo(rng);
					}
				}
				else   //病人离开系统
				{
					//cout << "test1" << endl;
					//离开部分
					if (Doctors[y].Doc_que.top().vip == 1) Doctors[y].vip_num--;

					if (Doctors[y].Doc_que.top().vip == 1)
						vip_Sumwaittime[Doctors[y].Doc_que.top()._intari] += Doctors[y].Doc_que.top().ons_waittime;//离开病人的总等待时间
					else
						common_Sumwaittime[Doctors[y].Doc_que.top()._intari] += Doctors[y].Doc_que.top().ons_waittime;//离开病人的总等待时间

					if (Doctors[y].Doc_que.empty()) {
						cout << "出大事儿了" << endl;
						cout << y << "  " << temp1 << endl;
						cout << "error ahjkh3 " << Doctors[0].next_finish_time << endl;
						cout << "error ahjkh3 " << Doctors[1].next_finish_time << endl;

						cout << "error ahjkh3 " << Doctors[0].internal << endl;
						cout << "error ahjkh3 " << Doctors[1].internal << endl;
						cout << "error ahjkdaaah3 " << Doctors[0].Doc_que.size() << endl;
						cout << "error ahjkdaaah3 " << Doctors[1].Doc_que.size() << endl;
						cout << "error ahjkdaaahss3 " << Pre_queue.size() << endl;


						system("pause");
					}

					Doctors[y].Doc_que.pop();  //医生外队列出队
					Doctors[y].internal--;   //内队列-1
					Doctors[y].next_finish_time = DBL_MAX;

					if (Doctors[y].internal == 0) {
						if (Doctors[y].workhour1 > (int)floor(slice * modtnow)) {
							workload[(int)floor(slice * modtnow)] += modtnow + timenum - double(Doctors[y].workhour2) / double(slice);
							//cout << modtnow<<" "<< Doctors[y].workhour1 <<" "<< Doctors[y].workhour2 <<" "<<modtnow + timenum - double(Doctors[y].workhour2) / double(slice) << endl;

							//cout << modtnow + timenum - Doctors[y].workhour2 <<" "<< modtnow<<" "<<y<<" "<<Doctors[y].workhour2<<endl;
							//system("pause");
						}
						else if (Doctors[y].workhour2 <= (int)floor(slice * modtnow)) {
							workload[(int)floor(slice * modtnow)] += modtnow - double(Doctors[y].workhour2) / double(slice);
							//cout << modtnow - Doctors[y].workhour2<<" " <<modtnow << " " << y << " " << Doctors[y].workhour2 << endl;
							//system("pause");
						}
					}

					if (Doctors[y].internal < 0) {// || Doctors[y].internal>4
						cout << "error ahjkh4 " << Doctors[0].internal << endl;
						cout << "error ahjkh4 " << Doctors[1].internal << endl;
						cout << "error ahjkdaaah4 " << Doctors[0].Doc_que.size() << endl;
						cout << "error ahjkdaaah4 " << Doctors[1].Doc_que.size() << endl;
						cout << "error ahjkdaaahss4 " << Pre_queue.size() << endl;

					}

					//if (Doctors[y].Doc_que.size() != 0)   //医生为下一个病人看病(瞬间被服务到了）
					if ((Doctors[y].Doc_que.size() != 0 && Doctors[y].Doc_que.top().vip == 1)//debug位置
						|| (Doctors[y].Doc_que.size() != 0 && Pre_queue.empty())
						|| (Doctors[y].Doc_que.size() != 0 && Pre_queue.top().vip != 1)
						)   //医生为内队列下一个病人看病 1 下一病人为高等级 2 下一病人为低等级但外队列没有高等级
					{
						//cout << "test3" << endl;

						Patient temp = Doctors[y].Doc_que.top();
						Doctors[y].Doc_que.pop();

						if (temp.first_come == true) //病人是第一次看到医生，记录是否超时并置firstcome属性为false
						{
							temp.ons_waittime += tnow - temp.arrivetime;
							if ((tnow - temp.arrivetime) > threshold)
							{
								if (temp.vip == 1) {
									vip_Overtimenum[temp._intari]++;  //初次等待时间超过阈值了
									//Static_Divide[0][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
								}
								else {
									common_Overtimenum[temp._intari]++;
									//Static_Divide[1][int((temp.arrivetime - double(round - 1) * timenum) * double(Static_Each_Period))]++;
								}
							}
							temp.first_come = false;
						}
						else {
							temp.ons_waittime += tnow - temp.lasttime;// to do  lasttime需要更新吗
						}

						Doctors[y].Doc_que.push(temp);
						Doctors[y].next_finish_time = tnow + doc_expo(rng);
					}
					else if (Doctors[y].Doc_que.size() != 0 && !Pre_queue.empty() && Pre_queue.top().vip == 1)// 内队列没有高等级，且外队列有高等级。 （外队列高等级插入进来）
					{


					}
					else if (Doctors[y].Doc_que.size() != 0) {
						cout << "error hjkhakh" << endl;
					}
					else
					{
						Doctors[y].next_finish_time = DBL_MAX;
					}

					//cout << "test2" << endl;

				}   //病人离开系统分支结束
			}   //医生分支结束

			if (temp_thing.what_type == 1)  //检查台分支开始
			{
				int y = temp_thing.which;  //是哪一个检查台？
				Nurses[y].next_finish_time = DBL_MAX;
				Patient temp = Nurses[y].Nur_que.top();
				temp.first_check++;
				if (temp.vip == 1) Nurses[y].vip_num--;
				Nurses[y].Nur_que.pop();
				temp.lasttime = tnow; //更新病人的lasttime，因为他马上要回到医生处排队了，需要统计新一轮的等待时间
				temp.FCFS_time = tnow;
				if (Doctors[temp.belongdoc].Doc_que.size() == 0)
					Doctors[temp.belongdoc].next_finish_time = tnow + doc_expo(rng);  //没人排队，直接生成服务完时间
				else if (Doctors[temp.belongdoc].Doc_que.top().vip == 2 && temp.vip == 1) //抢占
				{
					Doctors[temp.belongdoc].next_finish_time = tnow + doc_expo(rng);
				}
				Doctors[temp.belongdoc].Doc_que.push(temp);  //病人回到原来的医生处
				if (!Nurses[y].Nur_que.empty())   Nurses[y].next_finish_time = tnow + nur_expo(rng);
			}  //检查台分支结束
		}
	}

	//清空内存
	while (!Pre_queue.empty()) Pre_queue.pop();
	for (int i = 0; i < maxdocnum; i++) { while (!Doctors[i].Doc_que.empty()) Doctors[i].Doc_que.pop(); }
	for (int i = 0; i < nursenum; i++) { while (!Nurses[i].Nur_que.empty()) Nurses[i].Nur_que.pop(); }
	delete[]Doctors;
	while (!events_que.empty()) events_que.pop();

	for (int i = 0; i < slice * timenum; i++)
	{
		totalnum += common_Sumwaitnum[i];
		totaltime += common_Sumwaittime[i];
		totalover += common_Overtimenum[i];
		totalload += workload[i];
		//cout << totaltime << endl;
		//cout << "第" << i << "时段普通到达人数：" << common_Sumwaitnum[i] << "    服务水平:" << 1 - (double)common_Overtimenum[i] / (double)common_Sumwaitnum[i] << "    等待时间:" << common_Sumwaittime[i] / (double)common_Sumwaitnum[i] << endl;
	}

	for (int i = 0; i < timenum; i++)
	{
		//cout << "第" << i << "时段vip到达人数：" << vip_Sumwaitnum[i] << "    服务水平:" << 1 - (double)vip_Overtimenum[i] / (double)vip_Sumwaitnum[i] << "    等待时间:" << vip_Sumwaittime[i] / (double)vip_Sumwaitnum[i] << endl;
	}

	int count[2] = { 0 };
	//cout << endl;

	for (int i = 0; i < timenum; i++) {
		//cout << "第" << i << "时段普通到达人数：" << endl;
		for (int s = 0; s < Static_Each_Period; s++)
		{
			//cout << "第" << double(i) + double(s) / double(Static_Each_Period) << "小时段普通到达人数:" << Sum_Divide[1][i * Static_Each_Period + s] << "    服务水平:" << 1 - (double)Static_Divide[1][i * Static_Each_Period + s] / (double)Sum_Divide[1][i * Static_Each_Period + s] << endl;
		}
	}

	for (int i = 0; i < timenum; i++) {
		//cout << "第" << i << "时段普通到达人数：" << endl;
		for (int s = 0; s < Static_Each_Period; s++)
		{
			//cout << "第" << double(i) + double(s) / double(Static_Each_Period) << "小时段高等级到达人数:" << Sum_Divide[0][i * Static_Each_Period + s] << "    服务水平:" << 1 - (double)Static_Divide[0][i * Static_Each_Period + s] / (double)Sum_Divide[0][i * Static_Each_Period + s] << endl;
		}
	}
	for (int i = 0; i < timenum; i++) {
		for (int s = 0; s < Static_Each_Period; s++)
		{
			//count[1] += Sum_Divide[1][i * timenum + s];
			//count[0] += Sum_Divide[0][i * timenum + s];
		}
	}

	//cout << totalnum << "  " << count[1] << "  " << count[0] << endl;
	//cout << countFailIn[0] << " : " << countFailIn[1] << "  " << count[0] << endl;

	avgwaittime = totaltime / (double)totalnum;
	cout << totaltime << " " << totalnum << " " << avgwaittime << " " << totalover << " " << totalload / totalday << endl;
	return  avgwaittime;
}
//将数组1的值复制给数组2
void convert(int a1[], int a2[], int tmpsche[]) {
	for (int i = 0; i < docnum * day; i++) {
		if (a1[i] == 0) {
			tmpsche[0]++;
		}
	}
	for (int i = 1; i < slice * timenum; i++) {
		int tmp = 0;
		for (int j = 0; j < docnum * day; j++) {
			if (a1[j] == i) {
				tmp = tmp + 1;
			}
			if (a2[j] == i) {
				tmp = tmp - 1;
			}
		}
		tmpsche[i] = tmpsche[i - 1] + tmp;
	}
}

void merge(int arr[], int arr2[], int l1, int mid, int r2, int temp[], int temp2[]) {
	int i = l1, j = mid + 1;
	int p = 0;
	while (i <= mid && j <= r2) {
		if (arr[i] > arr[j]) {
			temp[p] = arr[j];
			temp2[p] = arr2[j];
			p++;
			j++;
		}
		else {
			temp[p] = arr[i];
			temp2[p] = arr2[i];
			p++;
			i++;
		}
	}

	while (i <= mid) {
		temp[p] = arr[i];
		temp2[p] = arr2[i];
		p++;
		i++;
	}
	while (j <= r2) {
		temp[p] = arr[j];
		temp2[p] = arr2[j];
		p++;
		j++;
	}
	//覆盖数组
	int n = r2 - l1 + 1;
	for (int i = 0; i < n; i++) {
		arr[l1 + i] = temp[i];
		arr2[l1 + i] = temp2[i];
		temp[i] = 0;
		temp2[i] = 0;
	}

}

void mergeSort(int arr[], int arr2[], int left, int right, int temp[], int temp2[]) {
	if (left < right) {
		int mid = (left + right) / 2;
		mergeSort(arr, arr2, left, mid, temp, temp2);     //分
		mergeSort(arr, arr2, mid + 1, right, temp, temp2);
		merge(arr, arr2, left, mid, right, temp, temp2); //合
	}

}

void copyarray(int a1[], int a2[], int a3 = docnum * day) {
	for (int i = 0; i < a3; i++) {
		a2[i] = a1[i];
	}
}

int checkfeasibility(int a1[], int a2[], int a3[]) {
	//printout(a1, a2, a3);
	int j = 0;
	for (int i = 0; i < day; i++) {
		nightshift[i] = 0;
		rest[i] = 0;
		shifts[i] = 0;
	}
	int tmpsche[slice * timenum] = { 0 };
	convert(a1, a2, tmpsche);
	//基础排班合理性
	int totalrest = 0;
	int totalshifts = 0;
	int totalnight = 0;
	for (int i = 0; i < docnum * day && j == 0; i++) {
		int tmp = a2[i] - a1[i];
		int day1 = a1[i] / (slice * timenum / day);
		int day2 = a2[i] / (slice * timenum / day);
		int hour1 = a1[i] - day1 * slice * (timenum / day);
		int hour2 = a2[i] - day2 * slice * (timenum / day);
		if (tmp > slice * maxwork || (tmp < slice * minwork && tmp != 0) || (day1 < day2 && hour2 != 0) || a1[i] < 0) {
			//cout << "wrong11 " <<i<< endl;
			j = 1;
			//break;
		}
		if (hour1 == slice * nightstart && tmp != slice * nightlong) {
			//cout << "wrong2" << endl;
			j = 1;
			//break;
		}
		if (hour2 == 0 && hour1 != slice * nightstart) {
			j = 1;
		}
		if (hour2 > slice * nightstart && hour2 < slice * timenum / day) {
			//cout << "wrong3" << endl;
			j = 1;
			//break;
		}
		if (hour1 > slice * nightstart && hour1 < slice * timenum / day) {
			//cout << "wrong3" << endl;
			j = 1;
			//break;
		}
		if (tmp == 0) {
			rest[day1]++;
		}
		if (hour1 == slice * nightstart && tmp == slice * nightlong) {
			nightshift[day1]++;
		}
		shifts[day1]++;
	}
	for (int i = 0; i < day; i++) {
		//cout << shifts[i] << " " << rest[i] << " " << nightshift[i] << endl;
	}
	//周排班合理性
	for (int i = 0; i < day && j == 0; i++) {
		totalrest += rest[i];
		totalnight += nightshift[i];
		//一个医生一天最多值一班
		if (shifts[i] > docnum) {
			j = 1;
			//cout << "wrong4" <<shifts[i]<< endl;
		}
		//夜班后要有休息一天
		if (i >= 1) {
			if (rest[i] < nightshift[i - 1]) {
				j = 1;
				//cout << "wrong5" <<rest[i]<<" " <<nightshift[i-1]<<endl;
			}
		}
		if (rest[i] < 1 || nightshift[i] < 1) {
			j = 1;
		}
	}
	if (rest[0] < nightshift[day - 1]) {
		j = 1;
		//cout << "wrong6" << endl;
	}
	//一个医生一周最多maxnight个夜班
	if (totalnight > maxnight * docnum) {
		j = 1;
		//cout << "wrong3" << endl;
	}
	//一个医生一周至少休息一天
	if (totalrest < docnum + totalnight) {
		j = 1;
		//cout << "wrong3" << endl;
	}
	//if (j == 1) { cout << "wrong1" << endl; }
	//每时刻都有医生上班,且M大于2
	for (int i = 0; i < Msli * timenum && j == 0; i++) {
		if (a3[i] < minM) {
			j = 1;
			break;
		}
		if (a3[i] > maxM) {
			j = 1;
		}
	}
	for (int i = 0; i < slice * timenum && j == 0; i++) {
		if (tmpsche[i] <= 0) {
			//cout << i << endl;
			//system("pause");
			j = 1;
			break;
		}
	}
	if (j == 1) {
		//cout << "infeas" << endl;
	}
	//system("pause"); 
	return j;
}

void primarysolution(int a, int pri_time, double b[], int s[], double mu = 1.0, int m = 4,int num=0, int type = 0) {

	for (int i = 0; i < Msli * timenum; i++) {
		M[i] = m;
	}
	for (int i = 0; i < docnum * day; i++) {
		workhours1[i] = slice * workhours1[i];
		workhours2[i] = slice * workhours2[i];
	}
	if (day == 1) {
		if (checkfeasibility(workhours1, workhours2, M) == 1) {
			cout << "给定解不可行" << endl;
			//system("pause");
			for (int i = 0; i < docnum * day; i++) {

				if (workhours1[i] == slice * nightstart) {
					workhours2[i] = workhours1[i] + nightlong * slice;
				}
				else {
					workhours2[i] = workhours1[i] + slice * pri_time;
				}
				if (workhours2[i] > slice * timenum) {
					workhours2[i] = slice * timenum;
				}
			}
		}
	}
	else {
		if (type == 0) {
			//周排班暂时先给可行初始解
			int tmpj = 0;
			int tmpi = 0;
			for (int i = 0; i < docnum * day; i++) {
				tmpj = i % docnum;
				tmpi = i / docnum;
				if (tmpj < s[0]) {//白班1
					workhours1[i] = timenum / day * slice * tmpi;
					workhours2[i] = workhours1[i] + pri_time * slice;
				}
				else if (tmpj < s[1]) {//白班2
					workhours1[i] = timenum / day * slice * tmpi + pri_time * slice;
					workhours2[i] = workhours1[i] + pri_time * slice;
				}
				else if (tmpj < s[2]) {//夜班
					workhours1[i] = timenum / day * slice * tmpi + nightstart * slice;
					workhours2[i] = workhours1[i] + nightlong * slice;
				}
				else {//休息
					workhours1[i] = timenum / day * slice * tmpi + resthour * slice;
					workhours2[i] = workhours1[i];
				}
			}
		}
		else {

		}

	}

	int tmpsche[slice * timenum] = { 0 };
	convert(workhours1, workhours2, tmpsche);
	for (int i = 0; i < slice * timenum; i++) {
		Schedule[i] = tmpsche[i];
	}

	if (mu == 0) {
		for (int i = 0; i < day; i++) {
			for (int j = 0; j < timenum / day; j++) {
				Arrive_rate[i * timenum / day + j] = Arrive_expp[num][i][j];
			}
		}
	}
	else {
		for (int i = 0; i < day; i++) {
			for (int j = 0; j < timenum / day; j++) {
				Arrive_rate[i * timenum / day + j] = Arrive_rate[j] * b[i];
			}
		}
		for (int i = 0; i < timenum; i++) {
			Arrive_rate[i] = Arrive_rate[i] * mu;
			//cout << Arrive_rate[i] << ",";
		}
	}
	outFile << "到达率为:";
	for (int i = 0; i < timenum; i++) {
		outFile << Arrive_rate[i] << ",";
	}
	outFile << endl;
	if (miu1 > 5.8) {
		outFile << "outbreak" << endl;
	}
	else {
		outFile << "stable" << endl;
	}
	outFile << "decodetype:" << decodetype << endl;
	if (checkfeasibility(workhours1, workhours2, M) == 1) {
		system("pause");
		cout << "初始解不可行" << endl;
	}
	copyarray(workhours1, tmp1);
	copyarray(workhours2, tmp2);
	copyarray(M, tmp3, Msli * timenum);
	/*
	copyarray(workhours1, bestwh1);
	copyarray(workhours2, bestwh2);
	copyarray(M, bestM, timenum);
	*/
}

double decode(int a11[], int a12[], int a3[], int type = decodetype) {
	int a1[docnum * day] = { 0 };
	int a2[docnum * day] = { 0 };
	double value = 0;
	double valuee1 = 0;
	double valuee2 = 0;
	double outcome = 0;
	double outcome2 = 0;
	for (int i = 0; i < docnum * day; i++) {
		a1[i] = a11[i];
		a2[i] = a12[i];
		//cout << a11[i] << a1[i] << a12[i] << a2[i] << endl;
		value = value + (double)((double)a2[i] - (double)a1[i]) / slice;
	}
	int tmpsche[slice * timenum] = { 0 };
	convert(a1, a2, tmpsche);
	for (int i = 0; i < slice * timenum; i++) {
		//cout <<i<<" "<< tmpsche[i] << endl;
		Schedule[i] = tmpsche[i];
	}
	srand(0);
	if (type == 1) {
		//system("pause");
		//rng.seed(std::random_device()());
		//printout(a1, a2, a3);
		//cout <<"总工作时长："<< value << endl;
		int temp[docnum * day] = { 0 };
		int temp2[docnum * day] = { 0 };
		mergeSort(a2, a1, 0, docnum * day - 1, temp, temp2);
		mergeSort(a1, a2, 0, docnum * day - 1, temp, temp2);
		for (int i = 0; i < docnum * day; i++) {
			//cout << a11[i] << a1[i] << a12[i] << a2[i] << endl;
		}
		//system("pause");
		string ss = "";
		if (nowtype == 1) {
			for (int i = 0; i < docnum * day; i++) {
				ss += to_string(a1[i]) + ",";
			}
			for (int i = 0; i < docnum * day; i++) {
				ss += to_string(a2[i]) + ",";
			}
			for (int i = 0; i < Msli * timenum; i++) {
				ss += to_string(a3[i]);
			}
			if (Hashmap1.find(ss) != Hashmap1.end()) {
				//cout << "found" << endl;
				outcome = Hashmap1.find(ss)->second;
			}
			else {
				//cout << "no findings" << endl;
				//cout << ss << endl;
				outcome = cor1 * (double)value + cor2 * Run_Case_Manager_2(a1, a2, tmpsche, a3) + cor3 * totalload / totalday;
				Hashmap1.insert(make_pair(ss, outcome));
			}
		}
		else {
			for (int i = 0; i < timenum * slice; i++) {
				ss += to_string(tmpsche[i]);
			}
			for (int i = 0; i < Msli * timenum; i++) {
				ss += to_string(a3[i]);
			}
			if (Hashmap0.find(ss) != Hashmap0.end()) {
				//cout << "found" << endl;
				outcome = Hashmap0.find(ss)->second;
				valuee1 = (outcome - cor1 * value) / cor2;
			}
			else {
				//cout << "no findings" << endl;
				//cout << ss << endl;
				valuee1 = Run_Case_Manager_1(tmpsche, a3);
				outcome = cor1 * (double)value + cor2 * valuee1 + cor3 * totalload / totalday;
				Hashmap0.insert(make_pair(ss, outcome));
			}
		}
		/*
		valuee2 = get_obj_value_ML_PSq(Arrive_rate, Schedule, a3);
		outcome2 = cor1 * (double)value + cor2 * valuee2;
		gaps.push_back(abs(valuee1 - valuee2) / valuee1);
		gapp += abs(valuee1 - valuee2) / valuee1;
		cout << "结果为：" << outcome << " " << outcome2 << " " << maxgap << " " << maxgap2 << " " << gapp / gaps.size() << endl;
		*/
	}
	else if (type == 2||type==4) {
		string ss = "";
		for (int i = 0; i < timenum * slice; i++) {
			ss += to_string(tmpsche[i]);
		}
		for (int i = 0; i < Msli * timenum; i++) {
			ss += to_string(a3[i]);
		}
		if (Hashmap2.find(ss) != Hashmap2.end()) {
			//cout << "found" << endl;
			outcome = Hashmap2.find(ss)->second;
		}
		else {
			//cout << "no findings" << endl;
			//cout << ss << endl;
			valuee1 = get_obj_value_ML_PSq(Arrive_rate, Schedule, a3);
			outcome = cor1 * (double)value + cor2 * valuee1 + cor3 * totalload / totalday;
			Hashmap2.insert(make_pair(ss, outcome));
		}
	}
	else if (type == 3) {
		int temp[docnum * day] = { 0 };
		int temp2[docnum * day] = { 0 };
		mergeSort(a2, a1, 0, docnum * day - 1, temp, temp2);
		mergeSort(a1, a2, 0, docnum * day - 1, temp, temp2);
		for (int i = 0; i < docnum * day; i++) {
			//cout << a11[i] << a1[i] << a12[i] << a2[i] << endl;
		}
		//system("pause");
		string ss = "";
		if (nowtype == 1) {
			for (int i = 0; i < docnum * day; i++) {
				ss += to_string(a1[i]) + ",";
			}
			for (int i = 0; i < docnum * day; i++) {
				ss += to_string(a2[i]) + ",";
			}
			for (int i = 0; i < Msli * timenum; i++) {
				ss += to_string(a3[i]);
			}
			if (Hashmap1.find(ss) != Hashmap1.end()) {
				//cout << "found" << endl;
				outcome = Hashmap1.find(ss)->second;
			}
			else {
				//cout << "no findings" << endl;
				//cout << ss << endl;
				outcome = cor1 * (double)value + cor2 * Run_Case_Manager_2(a1, a2, tmpsche, a3) + cor3 * totalload / totalday;
				Hashmap1.insert(make_pair(ss, outcome));
			}
		}
		else {
			for (int i = 0; i < timenum * slice; i++) {
				ss += to_string(tmpsche[i]);
			}
			for (int i = 0; i < Msli * timenum; i++) {
				ss += to_string(a3[i]);
			}
			if (Hashmap0.find(ss) != Hashmap0.end()) {
				//cout << "found" << endl;
				outcome = Hashmap0.find(ss)->second;
				valuee1 = (outcome - cor1 * value) / cor2;
			}
			else {
				//cout << "no findings" << endl;
				//cout << ss << endl;
				valuee1 = Run_Case_Manager_1(tmpsche, a3);
				outcome = cor1 * (double)value + cor2 * valuee1 + cor3 * totalload / totalday;
				Hashmap0.insert(make_pair(ss, outcome));
			}
		}
		valuee2 = get_obj_value_ML_PSq(Arrive_rate, Schedule, a3);
		outcome2 = cor1 * (double)value + cor2 * valuee2;
		gaps.push_back(abs(valuee1 - valuee2) / valuee1);
		gapp += abs(valuee1 - valuee2) / valuee1;
		cout << "结果为：" << outcome << " " << outcome2 << " " << maxgap << " " << maxgap2 << " " << gapp / gaps.size() << endl;
	}
	if (abs(outcome - outcome2) / outcome > maxgap) {
		maxgap = abs(outcome - outcome2) / outcome;
	}
	if (abs(outcome - outcome2) > abs(maxgap2)) {
		maxgap2 = outcome - outcome2;
	}
	//cout << "结果为：" << outcome << endl;
	return outcome;
}

void shake1(int a) {
	Sleep(1.0);
	srand(time(NULL));
	cout << "shake:" << a + shakeadd << endl;
	copyarray(workhours1, tmp1);
	copyarray(workhours2, tmp2);
	copyarray(M, tmp3, Msli * timenum);
	int ta = 0;
	int ran_doc[docnum * day] = { 0 };
	int ran_position, ran_long = 0;
	int doc_flag = 0;
	for (int i = 0; i < a + shakeadd; i++) {
		ta = 0;
		do {
			copyarray(tmp1, tmpwk1);
			copyarray(tmp2, tmpwk2);
			copyarray(tmp3, tmpM, Msli * timenum);
			do {
				doc_flag = 0;
				ran_doc[i] = rand() % (docnum * day);
				if (tmpwk1[ran_doc[i]] == tmpwk2[ran_doc[i]]) {
					doc_flag = 1;//shake不考虑改变休息的人
				}
				for (int j = 0; j < i; j++) {
					if (ran_doc[i] == ran_doc[j]) {
						doc_flag = 1;
						break;
					}
				}

			} while (doc_flag == 1);
			do {
				ran_position = rand() % (slice * timenum / day);
				ran_long = rand() % (slice * (maxwork - minwork) + 1) + slice * minwork;
			} while (ran_position == tmpwk1[ran_doc[i]]);
			//tmpM[tmpwk2[ran_doc[i]]]--;
			int day1 = tmpwk1[ran_doc[i]] / (slice * timenum / day);
			tmpwk1[ran_doc[i]] = ran_position + day1 * slice * timenum / day;
			if (rand() % 3 < 2) {
				tmpwk2[ran_doc[i]] = tmpwk1[ran_doc[i]] + ran_long;
				if (ran_position > slice * nightstart) {
					tmpwk1[ran_doc[i]] = slice * day1 * (timenum / day) + slice * nightstart;
					tmpwk2[ran_doc[i]] = slice * (day1 + 1) * (timenum / day);
				}
			}
			else {
				tmpwk1[ran_doc[i]] = timenum / day * slice * day1 + resthour * slice;
				tmpwk2[ran_doc[i]] = tmpwk2[ran_doc[i]];
			}
			//int hour2 = tmpwk2[ran_doc[i]] - day2 * slice * (timenum / day);

			ta++;
			if (ta > 1000) {
				cout << "nooo" << endl;
				printout(tmp1, tmp2, tmp3);
				cout << ran_doc[i] << " " << tmp1[ran_doc[i]] << " " << tmp2[ran_doc[i]] << endl;
				system("pause");
			}

		} while (checkfeasibility(tmpwk1, tmpwk2, tmpM) == 1);
		copyarray(tmpwk1, tmp1);
		copyarray(tmpwk2, tmp2);
		copyarray(tmpM, tmp3, Msli * timenum);
	}
	int tmmpM = rand() % 3 + 5;
	for (int i = 0; i < Msli * timenum; i++) {
		if (ifM == 1) {
			tmp3[i] = tmmpM;
		}
	}
}

double neibour1(int a, int b) {
	//int ta = 0;
	double localopt = 1000000;
	double nowopt = 0;
	int tmpt = 0;
	int day1, day2, hour1, hour2 = 0;
	cout << "邻域搜索开始" << endl;
	copyarray(tmp1, tmpwk1);
	copyarray(tmp2, tmpwk2);
	copyarray(tmp3, tmpM, Msli * timenum);
	copyarray(tmp1, bestwk1);
	copyarray(tmp2, bestwk2);
	copyarray(tmp3, bestM, Msli * timenum);
	//printout(tmp1, tmp2, tmp3);
	if (a == 0) {//尾时长变化
		for (int i = 0; i < docnum * day; i++) {
			tmp2[i] = tmp2[i] + 1;
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3, b);
				if (nowopt < localopt) {
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					//change_num = i;
					//change_type = 1;
					localopt = nowopt;
				}
			}
			tmp2[i] = tmp2[i] - 2;
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3, b);
				if (nowopt < localopt) {
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					//change_num = i;
					//change_type = 0;
					localopt = nowopt;
				}
			}
			tmp2[i] = tmp2[i] + 1;
		}
	}
	if (a == 1) {//时长平移 首时长变化
		for (int i = 0; i < docnum * day; i++) {
			//cout << i << endl;
			tmp1[i] = tmp1[i] + 1;
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3, b);
				if (nowopt < localopt) {
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					//change_num = i;
					//change_type = 1;
					localopt = nowopt;
				}
			}
			tmp1[i] = tmp1[i] - 2;
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3, b);
				if (nowopt < localopt) {
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					//change_num = i;
					//change_type = 0;
					localopt = nowopt;
				}
			}
			tmp1[i] = tmp1[i] + 1;
			/*
			tmpt = 0;
			tmp1[i] = tmp1[i] - 1;
			tmp2[i] = tmp2[i] - 1;
			day1 = tmp1[i] / (slice * timenum / day);
			hour1 = tmp1[i] - day1 * slice * (timenum / day);
			if (hour1 == slice * nightlong - 1) {
				//tmpt = tmp1[i] + 1;
				tmp1[i] = slice * nightlong + day1 * slice * (timenum / day);
			}
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3);
				if (nowopt < localopt) {
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					//change_num = i;
					//change_type = 0;
					localopt = nowopt;
				}
			}
			else {
				//printout(tmp1, tmp2, tmp3);
			}
			copyarray(tmpwk1, tmp1);
			copyarray(tmpwk2, tmp2);
			tmp1[i]++;
			tmp2[i]++;
			day2 = tmp2[i] / (slice * timenum / day);
			//hour2 = tmp2[i] - day2 * slice * timenum / day;
			if (day2 > day1) {
				tmp2[i] = day2 * slice * (timenum / day);
			}
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3);
				if (nowopt < localopt) {
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					//change_num = i;
					//change_type = 1;
					localopt = nowopt;
				}
			}
			copyarray(tmpwk1, tmp1);
			copyarray(tmpwk2, tmp2);
			*/
		}
	}
	if (a == 4) {//M变化
		for (int i = 0; i < Msli * timenum; i++) {
			//cout << "M变换时段" << i << endl;
			tmp3[i] = tmp3[i] + 1;
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3, b);
				if (nowopt < localopt) {
					//change_num = i;
					//change_type = 1;
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					localopt = nowopt;
				}
			}
			tmp3[i] = tmp3[i] - 2;
			if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
				nowopt = decode(tmp1, tmp2, tmp3, b);
				if (nowopt < localopt) {
					//change_num = i;
					//change_type = 0;
					copyarray(tmp1, bestwk1);
					copyarray(tmp2, bestwk2);
					copyarray(tmp3, bestM, Msli * timenum);
					localopt = nowopt;
				}
			}
			tmp3[i] = tmp3[i] + 1;
		}
	}
	if (a == 3) {//夜班变化
		int ifMove[day] = { 0 };
		for (int i = 0; i < docnum * day; i++) {
			day1 = tmp1[i] / (slice * timenum / day);
			hour1 = tmp1[i] - day1 * slice * (timenum / day);
			day2 = tmp2[i] / (slice * timenum / day);
			hour2 = tmp2[i] - day2 * slice * timenum / day;
			int temp = tmp1[i] = tmp2[i];
			if (hour1 == nightstart * slice && temp == nightlong * slice) {
				if (ifMove[day1] == 1) {
					continue;
				}
				ifMove[day1] = 1;
				for (int j = 0; j < slice * (timenum / day - nightlong); j++) {
					tmp1[i] = j + day1 * slice * (timenum / day);
					tmp2[i] = tmp1[i] + slice * nightlong;
					if (tmp2[i] > slice * nightstart) {
						tmp2[i] = slice * nightstart + day1 * slice * (timenum / day);
					}
					if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
						//printout(tmp1, tmp2, tmp3);
						nowopt = decode(tmp1, tmp2, tmp3, b);
						if (nowopt < localopt) {
							//change_num = j;
							//change_type = i;
							copyarray(tmp1, bestwk1);
							copyarray(tmp2, bestwk2);
							copyarray(tmp3, bestM, Msli * timenum);
							localopt = nowopt;
						}
					}
					copyarray(tmpwk1, tmp1);
					copyarray(tmpwk2, tmp2);
				}
			}
			else {
				tmp1[i] = day1 * slice * (timenum / day) + slice * nightstart;
				tmp2[i] = tmp1[i] + slice * nightlong;
				//第二天班次减少
				//
				if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
					//printout(tmp1, tmp2, tmp3);
					nowopt = decode(tmp1, tmp2, tmp3, b);
					if (nowopt < localopt) {
						//change_num = i;
						//change_type = -1;
						copyarray(tmp1, bestwk1);
						copyarray(tmp2, bestwk2);
						copyarray(tmp3, bestM, Msli * timenum);
						localopt = nowopt;
					}
				}

				copyarray(tmpwk1, tmp1);
				copyarray(tmpwk2, tmp2);
			}
		}
	}
	if (a == 2) {//休息和上班的转换
		int ifchange[day] = { 0 };
		for (int i = 0; i < docnum * day; i++) {
			day1 = tmp1[i] / (slice * timenum / day);
			//hour1 = tmp1[i] - day1 * slice * (timenum / day);
			//day2 = tmp2[i] / (slice * timenum / day);
			//hour2 = tmp2[i] - day2 * slice * timenum / day;
			if (tmp1[i] == tmp2[i]) {
				if (ifchange[day1] == 1) {
					continue;
				}
				ifchange[day1] = 1;
				for (int j = 0; j < slice * (timenum / day - nightstart); j++) {
					tmp1[i] = j + day1 * slice * (timenum / day);
					tmp2[i] = tmp1[i] + slice * minwork;
					if (tmp2[i] > slice * nightstart) {
						tmp2[i] = slice * nightstart + day1 * slice * (timenum / day);
					}
					if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
						//printout(tmp1, tmp2, tmp3);
						nowopt = decode(tmp1, tmp2, tmp3, b);
						if (nowopt < localopt) {
							//change_num = j;
							//change_type = i;
							copyarray(tmp1, bestwk1);
							copyarray(tmp2, bestwk2);
							copyarray(tmp3, bestM, Msli * timenum);
							localopt = nowopt;
						}
					}
					copyarray(tmpwk1, tmp1);
					copyarray(tmpwk2, tmp2);
				}

			}
			else {
				tmp1[i] = timenum / day * slice * day1 + resthour * slice;
				tmp2[i] = tmp1[i];
				if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
					//printout(tmp1, tmp2, tmp3);
					nowopt = decode(tmp1, tmp2, tmp3, b);
					if (nowopt < localopt) {
						copyarray(tmp1, bestwk1);
						copyarray(tmp2, bestwk2);
						copyarray(tmp3, bestM, Msli * timenum);
						localopt = nowopt;
					}
				}
				copyarray(tmpwk1, tmp1);
				copyarray(tmpwk2, tmp2);
			}
		}
	}
	if (a == 5) {//测试邻域
		for (int i = 0; i < docnum * day; i++) {
			for (int j = 0; j < docnum * day; j++) {
				if (j != i) {
					tmp2[i]--;
					tmp2[j]++;
					if (checkfeasibility(tmp1, tmp2, tmp3) == 0) {
						nowopt = decode(tmp1, tmp2, tmp3, b);
						if (nowopt < localopt) {
							//change_num = i;
							//change_type = j;
							copyarray(tmp1, bestwk1);
							copyarray(tmp2, bestwk2);
							copyarray(tmp3, bestM, Msli * timenum);
							localopt = nowopt;
						}
					}
					copyarray(tmpwk1, tmp1);
					copyarray(tmpwk2, tmp2);
				}
			}
		}
	}
	return localopt;
}

void solutiontest(int a1[], int a2[], int a3[], double mu, double b[]) {

	for (int i = 0; i < docnum * day; i++) {
		a1[i] = slice * a1[i];
		a2[i] = slice * a2[i];
	}
	int aa3[Msli * timenum] = { 0 };
	for (int i = 0; i < Msli * timenum; i++) {
		aa3[i] = a3[i / Msli];
	}
	int tmpsche[slice * timenum] = { 0 };
	convert(a1, a2, tmpsche);
	for (int i = 0; i < slice * timenum; i++) {
		Schedule[i] = tmpsche[i];
	}
	for (int i = 0; i < day; i++) {
		for (int j = 0; j < timenum / day; j++) {
			Arrive_rate[i * timenum / day + j] = Arrive_rate[j] * b[i];
		}
	}
	for (int i = 0; i < timenum; i++) {
		Arrive_rate[i] = Arrive_rate[i] * mu;
	}
	printout(a1, a2, aa3);
	decode(a1, a2, aa3);
	system("pause");
}

void solutiontest2() {

	int Schedule1[timenum] = { 4,5,6,6,6,6,6,6,7,6,5,5,5,5,5,5,2,2,2,2,2,2,2,2,3,6,6,7,8,8,8,8,8,5,5,4,3,3,3,3,2,2,2,2,2,2,2,2,4,4,6,6,6,6,6,6,3,2,5,5,5,5,5,5,3,3,3,3,3,3,3,3,4,5,5,6,6,6,7,7,6,5,5,4,4,4,3,3,3,3,3,3,3,3,3,3,4,4,4,7,7,7,7,6,7,6,6,4,4,4,4,4,2,2,2,2,2,2,2,2,4,6,6,7,7,7,7,7,7,5,5,4,4,4,4,4,2,2,2,2,2,2,2,2,4,5,6,6,6,6,7,8,7,6,5,5,5,5,4,3,2,2,2,2,2,2,2,2, 
	};
	int a3[timenum] = { 5,8,8,8,6,5,5,6,6,9,5,5,6,7,5,7,5,9,6,9,5,5,7,9,7,8,7,7,8,9,5,7,5,9,5,7,7,6,9,6,5,5,6,6,5,7,8,9,9,5,7,9,9,5,6,7,5,9,9,5,5,7,7,7,6,5,9,5,6,8,7,9,6,9,6,5,9,6,6,5,6,9,6,6,7,6,5,6,9,8,9,5,5,7,5,7,5,9,6,7,5,9,5,6,5,8,8,6,6,5,5,7,5,5,9,5,9,5,5,9,5,9,7,9,9,9,5,8,7,5,9,9,7,6,5,7,5,5,7,5,5,8,8,7,8,5,9,9,6,9,5,6,8,9,9,8,7,6,6,7,5,5,7,7,6,8,5,5 };
	int number = 0;
	int number1 = 0;
	copyarray(Schedule1, Schedule, timenum);
	for (int i = 0; i < timenum; i++) {
		number = number + Schedule1[i];
	}
	cout << number << endl;
	for (int i = 0; i < day; i++) {
		for (int j = 0; j < timenum / day; j++) {
			Arrive_rate[i * timenum / day + j] = Arrive_expp[1][i][j];
		}
	}
	cout << (double)number + cor2 * Run_Case_Manager_1(Schedule, M) << endl;
	cout << get_obj_value_ML_PSq(Arrive_rate, Schedule, M) << endl;
	cout << (double)number + cor2 * get_obj_value_ML_PSq(Arrive_rate, Schedule,M) << endl;

	system("pause");
}

int solutionmatch(int allocate[day][docnum], int allshift[day][docnum]) {//2休息，1夜班，0正常
	for (int i = 0; i < day; i++) {
		for (int j = 0; j < docnum; j++) {
			allocate[i][j] = 0;
			cout << allshift[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	//system("pause");
	int tmpnight = 0;
	int flagdoc = 0;

	int nightallocate = 0;
	for (int i = 0; i < day; i++) {
		for (int j = 0; j < docnum; j++) {
			if (allshift[i][j] == 1) {//如果此班是夜班
				nightallocate = nightallocate % docnum + 1;
				if (flagdoc == 1) {
					if (i == day - 1) {
						for (int ii = nightallocate - 1; ii < docnum; ii++) {
							int flagfind = 0;
							for (int jj = 0; jj < docnum; jj++) {
								if (allocate[i - 1][jj] == ii + 1) {
									flagfind = 1;
									break;
								}
								if (allocate[0][jj] == ii + 1) {
									flagfind = 1;
									break;
								}
								if (allocate[i][jj] == ii + 1) {
									flagfind = 1;
									break;
								}
							}
							if (flagfind == 0) {
								allocate[i][j] = ii + 1;
								break;
							}
						}
					}
					else {
						allocate[i][j] = nightallocate;
						if (nightallocate == docnum && flagdoc == 0) {
							flagdoc = 1;
						}
					}
				}
				else {
					allocate[i][j] = nightallocate;
					if (nightallocate == docnum && flagdoc == 0) {
						flagdoc = 1;
					}
				}

			}
		}
	}
	int fla = 0;
	while (fla == 0) {
		fla = 1;
		int spi = 0, spj = 0;
		for (int i = 0; i < day; i++) {
			for (int j = 0; j < docnum; j++) {
				if (allshift[i][j] == 1 && allocate[i][j] == 0) {
					fla = 0;
					spi = i;
					spj = j;
				}
			}
		}

	}
	//先分配夜班对应的休息
	for (int i = 0; i < day - 1; i++) {
		for (int j = 0; j < docnum; j++) {
			if (allshift[i][j] == 1) {
				tmpnight++;
				for (int jj = 0; jj < docnum; jj++) {
					if (allshift[i + 1][jj] == 2 && allocate[i + 1][jj] == 0) {
						allocate[i + 1][jj] = allocate[i][j];
						break;
					}
				}
			}
		}
	}
	for (int j = 0; j < docnum; j++) {
		if (allshift[day - 1][j] == 1) {
			tmpnight++;
			for (int jj = 0; jj < docnum; jj++) {
				if (allshift[0][jj] == 2 && allocate[0][jj] == 0) {
					allocate[0][jj] = allocate[day - 1][j];
					break;
				}
			}
		}
	}
	/*
	if (tmpnight >= docnum) {
		flagdoc = 1;
	}
	else {
		nightallocate = tmpnight;
	}
	*/
	flagdoc = 0;
	nightallocate = 0;
	for (int i = 0; i < day; i++) {
		for (int j = 0; j < docnum; j++) {
			if (allshift[i][j] == 2 && allocate[i][j] == 0) {
				if (flagdoc == 0) {
					nightallocate = nightallocate % docnum + 1;
					allocate[i][j] = nightallocate;
					if (nightallocate == docnum) {
						flagdoc = 1;
					}
				}
				else {
					for (int ii = 0; ii < docnum; ii++) {
						int flagfind = 0;
						for (int jj = 0; jj < docnum; jj++) {
							if (allocate[i][jj] == ii + 1) {
								flagfind = 1;
								break;
							}
						}
						if (flagfind == 0) {
							allocate[i][j] = ii + 1;
							break;
						}
					}
				}
			}
		}
	}
	for (int i = 0; i < day; i++) {
		for (int j = 0; j < docnum; j++) {
			if (allocate[i][j] == 0 && allshift[i][j] == 0) {
				for (int ii = 0; ii < docnum; ii++) {
					int flagfind = 0;
					for (int jj = 0; jj < docnum; jj++) {
						if (allocate[i][jj] == ii + 1) {
							flagfind = 1;
							break;
						}
					}
					if (flagfind == 0) {
						allocate[i][j] = ii + 1;
						break;
					}
				}
			}
		}
	}


	for (int i = 0; i < day; i++) {
		for (int j = 0; j < docnum; j++) {
			cout << allocate[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	//system("pause");
	return 0;
}

void shiftsort(int a1[], int a2[], int a3[]) {
	for (int i = 0; i < day; i++) {
		nightshift[i] = 0;
		rest[i] = 0;
	}
	int allshift[day][docnum] = { 0 };
	int allocate[day][docnum] = { 0 };
	int day1 = 0, day2 = 0, hour1 = 0, hour2 = 0;
	int nowday = 0;
	int j = 0;
	for (int i = 0; i < docnum * day; i++) {
		day1 = a1[i] / (slice * timenum / day);
		day2 = a2[i] / (slice * timenum / day);
		hour1 = a1[i] - day1 * slice * (timenum / day);
		hour2 = a2[i] - day2 * slice * (timenum / day);
		int temp = a2[i] - a1[i];
		if (a2[i] == a1[i]) {
			allshift[day1][j] = 2;
		}
		else if (hour1 == slice * nightstart && temp == slice * nightlong) {
			allshift[day1][j] = 1;
		}
		else {
			allshift[day1][j] = 0;
		}
		j = (j + 1) % docnum;
	}
	solutionmatch(allocate, allshift);
}

void paracheck() {
	if (nightlong + nightstart != timenum / day) {
		cout << "wrong" << endl;
		system("pause");
	}
}

int main()
{
	init_py();
	for (int iii = 1; iii < numcase; iii++) {
		outFile << "数值实验" << iii << endl;
		cout << "数值实验" << iii << endl;
		paracheck();
		time_t start, stop;
		start = time(NULL);
		srand(0);
		//solutiontest(workhours1, workhours2, M,0.8,Arrive_ratio);
		solutions.clear();
		searchtimes.clear();
		Hashmap0.clear();
		Hashmap1.clear();
		Hashmap2.clear();
		primarysolution(0, 8, Arrive_ratio, s, 0, defaultM,iii);
		solutiontest2();
		//cout << get_obj_value_ML_PSq(Arrive_rate,Schedule,M) << endl;
		//cout << get_obj_value_ML_PSq(Arrive_rate, Schedule, M) << endl;
		printout(workhours1, workhours2, M);
		wholebest = decode(workhours1, workhours2, M, 1);
		//system("pause");
		solutions.push_back(wholebest);
		int flagk = 0;
		int shakes = 0;
		int flagi = 0;
		int searchnum = 0;
		int decodet = decodetype;
		for (int i = 0; i < iteras; i++) {
			cout << i << "迭代：" << endl;
			//if(i!=0)
			shake1(shakes % K);
			bestvalue = decode(tmp1, tmp2, tmp3, decodet);
			cout << bestvalue << endl;
			decodet = decodetype;
			for (int k = 0; k < K; k++) {
				flagk = 0;
				cout << k << endl;

				if (decodet == 4 && k == 4) {
					//continue;
				}
				else {
					lastvalue = neibour1(k, decodet);
				}
				searchnum++;
				if (lastvalue < bestvalue) {
					cout << bestvalue << " " << lastvalue << endl;
					copyarray(bestwk1, tmp1);
					copyarray(bestwk2, tmp2);
					copyarray(bestM, tmp3, Msli * timenum);
					//printout(workhours1, workhours2, M);
					bestvalue = lastvalue;
					flagk = 1;
				}
				cout << "迭代" << i << "邻域" << k << "最好值为" << bestvalue << " " << wholebest << endl;
				//printout(tmp1, tmp2, tmp3);
				if (flagk == 1) {
					k = -1;
				}
				if (lastvalue < solutions.back()) {
					solutions.push_back(lastvalue);
					searchtimes.push_back(searchnum);
				}
				if (k == K - 1) {
					if (decodet==4) {
						decodet = 1;
						k = -1;
						bestvalue = decode(tmp1, tmp2, tmp3,1);
					}
				}
				//printout(workhours1, workhours2, M);
				//cout << i << endl;
			}
			cout << "当前最优：" << bestvalue << " 全局最优为：" << wholebest << endl;

			if (bestvalue < wholebest) {
				copyarray(tmp1, workhours1);
				copyarray(tmp2, workhours2);
				copyarray(tmp3, M, Msli * timenum);
				cout << endl;
				shakes = 0;
				wholebest = bestvalue;
				flagi = i;
			}
			else {
				shakes++;
			}
			cout << "出现全局最优的迭代：" << flagi << " 当前全局最优为：" << endl;
			printout(workhours1, workhours2, M);
			shiftsort(workhours1, workhours2, M);
			cout << wholebest << endl;
			for (int i = 0; i < solutions.size(); i++) {
				cout << solutions[i] << ",";
			}
			cout << endl;
			for (int i = 0; i < searchtimes.size(); i++) {
				cout << searchtimes[i] << ",";
			}
			cout << endl;
		}

	    outFile << "出现全局最优的迭代：" << flagi << " 当前全局最优为：" << endl;
		printout(workhours1, workhours2, M, 2);
		outFile << "最优解仿真值为" << decode(workhours1, workhours2, M, 1) << endl;
		outFile << wholebest << endl;
		for (int i = 0; i < solutions.size(); i++) {
			outFile << solutions[i] << ",";
		}
		outFile << endl;
		for (int i = 0; i < searchtimes.size(); i++) {
			outFile << searchtimes[i] << ",";
		}
		outFile << endl;
		for (int i = 0; i < gaps.size(); i++) {
			cout << gaps[i] << ",";
			outFile << gaps[i] << ",";
		}
		cout << endl;
		outFile << endl;
		stop = time(NULL);
		cout << "所用时间为" << stop - start << "s" << endl;
		outFile << "所用时间为" << stop - start << "s" << endl;
		outFile << stop << endl;
		cout << nowtype << endl;
	}
	return 0;
}

